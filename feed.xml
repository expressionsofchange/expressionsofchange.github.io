<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
<title type="text">Expressions of Change</title>
<generator uri="https://github.com/mojombo/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="http://expressionsofchange.com/feed.xml" />
<link rel="alternate" type="text/html" href="http://expressionsofchange.com" />
<updated>2017-11-16T17:18:51+01:00</updated>
<id>http://expressionsofchange.com/</id>
<author>
  <name>Klaas van Schelven</name>
  <uri>http://expressionsofchange.com/</uri>
  <email>klaas@vanschelven.com</email>
</author>


<entry>
  <title type="html"><![CDATA[L - A toy language]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/l-a-toy-language/" />
  <id>http://expressionsofchange.com/l-a-toy-language</id>
  <published>2017-11-16T00:00:00+01:00</published>
  <updated>2017-11-16T00:00:00+01:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;p&gt;The &lt;a href=&quot;/the-editor/&quot;&gt;editor that is part of this project&lt;/a&gt; puts changes to documents more centrally in the editing experience than traditional editors. In defining a language for static analysis, however, we shall start by focusing on the structure that can be constructed from these changes: an s-expression.&lt;/p&gt;

&lt;p&gt;S-expressions are perhaps most well-known for being the basic building block of the syntax of Lisp and its various dialects. In this series we will stay true to that tradition, defining a minimal Lisp as the basis for further discussion. In the below, we shall refer to this language as &lt;em&gt;L&lt;/em&gt;. Despite being quite minimal, &lt;em&gt;L&lt;/em&gt; is sufficiently complete for actual usage, and for various static analyses to yield interesting results.&lt;/p&gt;

&lt;p&gt;The given language is a subset of Scheme. In the interest of brevity the definition below is somewhat imprecise; for a full definition of Scheme the reader is referred to &lt;a href=&quot;https://mitpress.mit.edu/sites/default/files/6515.pdf&quot;&gt;the excellent book by Abelson &amp;amp; Sussman&lt;/a&gt; or the accompanying &lt;a href=&quot;https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/&quot;&gt;video lectures&lt;/a&gt;. A more precise definition of the language under consideration here may be obtained by taking Scheme as defined in those sources, and limiting it to the special forms as defined below.&lt;/p&gt;

&lt;h2 id=&quot;operational-semantics&quot;&gt;Operational semantics&lt;/h2&gt;

&lt;p&gt;In the below we provide an &lt;em&gt;operational semantics&lt;/em&gt;, which is to say: the meaning of the language is entirely defined by its behavior in some imaginary machine. In particular, given an s-expression and an environment, we provide a mechanism for evaluation.&lt;/p&gt;

&lt;p&gt;S-expressions have been talked about at length &lt;a href=&quot;/introducing-the-editor/&quot;&gt;in our description of the editor&lt;/a&gt;; With regards to environments, it suffices to say two things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Environments bind values to names; after a value has been bound to a name, looking up the name returns the value.&lt;/li&gt;
  &lt;li&gt;Environments may be nested; if a name is looked up in a nested environment and not found there, lookup recursively proceeds in the enclosing environment.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;case-analysis&quot;&gt;Case-analysis&lt;/h3&gt;

&lt;p&gt;We define evaluation in terms of a case-analysis on the shape of the s-expression. For list expressions, we use a pattern-matching-like notation for this shape; the reader is expected to be able to either deal with the lack of precision, or look up a more precise definition in the above-mentioned sources. Note that the definition is recursive: some of the mechanisms of evaluation below are defined in terms of further evaluation.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;an atom which is either a string or a numbers is a &lt;strong&gt;value&lt;/strong&gt;; its evaluation results in this value itself.&lt;/li&gt;
  &lt;li&gt;any other atom is a &lt;strong&gt;variable&lt;/strong&gt;; its evaluation results in the value resulting from looking up this variable in the present environment.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(quote «s-expr»)&lt;/code&gt; is a &lt;strong&gt;quoted expression&lt;/strong&gt;; its evaluation results in the quoted s-expression as-is (i.e., specifically by not further evaluation the quoted s-expression).&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(quote «predicate» «consequent» «alternative»)&lt;/code&gt; is an &lt;strong&gt;if-expression&lt;/strong&gt;; its evaluation depends on the value resulting from evaluating the &lt;em&gt;predicate&lt;/em&gt;; if this is &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, it is the result of evaluating of the &lt;em&gt;conseqeuent&lt;/em&gt;, otherwise that of evaluating the &lt;em&gt;alternative&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(define «variable-name» «definition»)&lt;/code&gt; is a &lt;strong&gt;definition&lt;/strong&gt;; its evaluation does not result in a (meaningful) value; however, as an effect of evaluating the result of evaluating the definition is bound to the variable-name in the present environment.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(lambda «parameter names» «body ...»)&lt;/code&gt; is a &lt;strong&gt;lambda&lt;/strong&gt;; it evaluates to a procedure object which contains the parameter names and body. (Note: unlike in Scheme, in which a special form of &lt;code class=&quot;highlighter-rouge&quot;&gt;define&lt;/code&gt; is interpreted as a procedure, in &lt;em&gt;L&lt;/em&gt; lambda’s can only be defined directly using the associated special form)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(begin «... ...»)&lt;/code&gt; is a &lt;strong&gt;sequence&lt;/strong&gt;; it evaluates each s-expression in turn, the evaluation of the sequence results in the last element’s evaluation.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(«procedure» «arguments ...»)&lt;/code&gt; is an &lt;strong&gt;procedure application&lt;/strong&gt;; evaluation results in the value that is arrived at as follows: first, evaluate the procedure and all arguments in the present environment. Create a new (sub-)environment in which each of the procedure’s parameter names is bound to the value of the associated argument. Evaluate the procedure’s body in this environment. This is the result of evaluating the procedure application.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For the sake of simplicity, &lt;em&gt;L&lt;/em&gt; has no primitive procedures; this is no problem, since we can always evaluate programs in some “global” environment in which all required primitive procedures are bound to some name.&lt;/p&gt;

&lt;h3 id=&quot;an-example&quot;&gt;An example&lt;/h3&gt;

&lt;p&gt;As an example, given this definition, consider the following s-expression:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;factorial&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;factorial&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))))&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;factorial&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Evaluating this in an environment where the mathematical symbols are bound to procedures expressing their usual meaning yields the value &lt;code class=&quot;highlighter-rouge&quot;&gt;120&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h3&gt;

&lt;p&gt;This concludes the definition of the language &lt;em&gt;L&lt;/em&gt;;&lt;/p&gt;

&lt;p&gt;In the next article in this series (as of yet: to be written) we will see a very first example of a static analysis on programs in &lt;em&gt;L&lt;/em&gt;, namely the analysis on the forms in such programs.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/l-a-toy-language/&quot;&gt;L - A toy language&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on November 16, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Static Analysis - Introduction]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/static-analysis-intro/" />
  <id>http://expressionsofchange.com/static-analysis-intro</id>
  <published>2017-11-15T00:00:00+01:00</published>
  <updated>2017-11-15T00:00:00+01:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;p&gt;Static program analysis is the analysis of computer programs that is performed without actually executing programs. Some examples are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;identifying variables that are declared, but never used;&lt;/li&gt;
  &lt;li&gt;identifying variables that are used, but never declared;&lt;/li&gt;
  &lt;li&gt;any kind of type-checker.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Such analyses are useful in helping the programmer identify potential errors as soon as possible.&lt;/p&gt;

&lt;p&gt;Case in point: running a program with undeclared variables will lead to failure at the point the variable is used, which is why running such programs is ruled out in many (but not all) programming environments.&lt;/p&gt;

&lt;p&gt;Let’s see how such analyses relate to the present project. This project is about &lt;em&gt;Expressions of Change&lt;/em&gt;: environments in which the changes to programs take a central role, e.g. by having an editor which stores histories of structured changes to documents rather than the resulting documents.&lt;/p&gt;

&lt;p&gt;In the context of such an editor, doing such static analyses for each version of the program yields an extra dimension of valuable information: in addition to giving information about &lt;em&gt;what&lt;/em&gt; is wrong and &lt;em&gt;where&lt;/em&gt;, such step by step analyses provide insight into &lt;em&gt;when&lt;/em&gt; something went wrong, in terms of the edit-history of your program. This extra dimension may be quite helpful in answering the most important question, which is the question as to &lt;em&gt;why&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;As an example, consider an analysis which identifies (attempted) usage of undeclared variables. A traditional such analysis will point at the location in our program where an unknown variable is used. Doing the same analysis for each version of the program (where &lt;em&gt;every&lt;/em&gt; modification of the program yields a new version) will help us pinpoint &lt;em&gt;when&lt;/em&gt; the problem was introduced. In other words: it will pinpoint a precise modification of the program. By examining this modification, the question of &lt;em&gt;why&lt;/em&gt; may be more readily answered. Examples of possible answers are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;the variable was renamed at its usage-location;&lt;/li&gt;
  &lt;li&gt;the variable was renamed at the location of its definition;&lt;/li&gt;
  &lt;li&gt;the location of the variable’s definition was removed entirely;&lt;/li&gt;
  &lt;li&gt;the variable has never been defined.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This principle, of applying a given static analysis on each version of the program as a whole, gives us a new axis of analysis “for free”, namely that along the history of the program’s construction. By “for free”, we mean that we need not write any code: we simply take an existing tool for static analysis and run it at each step of the program’s construction. One might call this principle the naive approach to step by step program analysis.&lt;/p&gt;

&lt;p&gt;In addition to this naive approach, we could consider approaches to step-wise static analysis which try to utilize both the structured nature of our editor and the stream of change-operations it produces. Such approaches to static analysis will take as input:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;a previous version of the program,&lt;/li&gt;
  &lt;li&gt;a finished analysis for that previous version of the program and&lt;/li&gt;
  &lt;li&gt;a single change to the program (or part of it).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are two important reasons to do so:&lt;/p&gt;

&lt;p&gt;The first is that the approach of running a full static analysis for each change to a program, might be “free” in terms of the effort to develop the analyses, but is certainly not free in terms of processing power! When we take this approach the amount of required processing power and time is multiplied by the number of changes we wish to analyze. This likely excludes many interesting use-cases, such as the one of interactive feedback on the output of static analyses.&lt;/p&gt;

&lt;p&gt;A second reason to consider a more incremental approach to static analysis is that such analyses, by virtue of their incremental formulation, may occasionally lead to output that is more easily understood by the human end-user of the analysis. In such analyses we spend quite some effort in precisely defining how various changes may affect the output of an analysis, and how information flows through a program, with the goal of reducing the analyses’ runtimes. It turns out this has the fortunate side-effect of saving processing power of the human interpreter of the result as well!&lt;/p&gt;

&lt;p&gt;In the past month I have written a number of such incremental static analyses; I will present the results here as a &lt;a href=&quot;/static-analysis/&quot;&gt;series of articles&lt;/a&gt;. In the &lt;a href=&quot;/l-a-toy-language/&quot;&gt;next article&lt;/a&gt; in the series we will define a small language, called &lt;em&gt;L&lt;/em&gt;, as a basis for various analyses.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/static-analysis-intro/&quot;&gt;Static Analysis - Introduction&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on November 15, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Constraints on Replace]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/constraints-on-replace/" />
  <id>http://expressionsofchange.com/constraints-on-replace</id>
  <published>2017-11-14T00:00:00+01:00</published>
  <updated>2017-11-14T00:00:00+01:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;p&gt;Before we do so, some quick pointers to important background information.&lt;/p&gt;

&lt;p&gt;The context of this article is &lt;a href=&quot;/introducing-the-editor/&quot;&gt;an editor of s-expressions&lt;/a&gt; in which the primitives are the mechanisms of construction rather than the resulting structures.&lt;/p&gt;

&lt;p&gt;Important examples of such primitives are the operations (&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Delete&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt;). These primitives may be composed; a list of them is called a history.&lt;/p&gt;

&lt;p&gt;The operation &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt;, in particular, replaces a child-node with a new one, where the new node is described recursively using a full history &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;; the child to be replaced is denoted by an index &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this article we will consider a possible constraint on this history &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; and its ramifications.&lt;/p&gt;

&lt;h2 id=&quot;a-continuation-of-history&quot;&gt;A continuation of history&lt;/h2&gt;

&lt;p&gt;The potential constraint that we will consider is the following: that &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; must be continuation of the history of the node previously existing at index &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;. We shall call this constraint “&lt;em&gt;continuation-only&lt;/em&gt;” and cases in which it does not apply “&lt;em&gt;any-history&lt;/em&gt;”.&lt;/p&gt;

&lt;p&gt;Let’s make this notion of history being a continuation of a previously existing history a bit more precise.&lt;/p&gt;

&lt;p&gt;First, note that we can always meaningfully talk about such a thing as “the history of the node at index &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;”: This is because the only way to add or modify children in the first place is by using the operations &lt;code class=&quot;highlighter-rouge&quot;&gt;Insert&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt;, and both of these operations take a history as an argument. All we need to do is, during construction of each child, keep a reference to the history out of which it was constructed. In the below, we will refer to such a pre-existing history as &lt;code class=&quot;highlighter-rouge&quot;&gt;h-pre&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So what is the relationship between &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;h-pre&lt;/code&gt; if a history is a continuation of another? As noted in the above, a history is simply a list of operations of change. Given that definition, we may formulate &lt;em&gt;continuation&lt;/em&gt; as follows: A history &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; is a continuation of another history &lt;code class=&quot;highlighter-rouge&quot;&gt;h-pre&lt;/code&gt; if the latter is a prefix of the former. In other words: the list &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; fully contains the list &lt;code class=&quot;highlighter-rouge&quot;&gt;h-pre&lt;/code&gt; at its beginning.&lt;/p&gt;

&lt;p&gt;An alternative, equivalent, formulation, is based on the following implementation detail for histories: In practice, we implement histories using a technique called &lt;a href=&quot;/hash-consing/&quot;&gt;hash consing&lt;/a&gt;. In short: the list is implemented as a linked list, where each element points to its predecessor using a hash. In this view, we can say that a history &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; is a continuation of another history &lt;code class=&quot;highlighter-rouge&quot;&gt;h-pre&lt;/code&gt; if you, by following the hashes from &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;, at some point will encounter the hash &lt;code class=&quot;highlighter-rouge&quot;&gt;h-pre&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To clarify what history continuation means in practice, let’s consider two examples:&lt;/p&gt;

&lt;h3 id=&quot;continuation-only&quot;&gt;Continuation-only&lt;/h3&gt;

&lt;p&gt;In the first example the history with which we replace is a continuation of the previously existing history:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 ...&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 (BecomeAtom *))&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 1 (BecomeAtom 6))&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Replace 0 ...&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 (BecomeAtom *))&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 1 (BecomeAtom 6))&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Delete 1&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(The notation of nested lists in the above should be interpreted as follows: each of the ellipses (&lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt;) are a single parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;, which is further detailed in the indented bullet points below it.)&lt;/p&gt;

&lt;p&gt;This is an example of a continuation of history, because the first 3 operations, up until &lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 1 (BecomeAtom 6))&lt;/code&gt; are shared between the pre-existing history &lt;code class=&quot;highlighter-rouge&quot;&gt;h-pre&lt;/code&gt; and the new history &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;any-history&quot;&gt;Any-history&lt;/h3&gt;

&lt;p&gt;In the second example the history with which we replace is &lt;em&gt;not&lt;/em&gt; a continuation of the pre-existing one.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 ...&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 (BecomeAtom *))&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 1 (BecomeAtom 6))&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Replace 0 ...&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 (BecomeAtom +))&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is an example where the constraint does not apply: the operations &lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 (BecomeAtom *))&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 1 (BecomeAtom 6))&lt;/code&gt; from &lt;code class=&quot;highlighter-rouge&quot;&gt;h-pre&lt;/code&gt; are not reflected in the history &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the below, we’ll consider the consequences enforcing &lt;em&gt;continuation-only&lt;/em&gt; from two perspectives: the perspective of the mental model of our programmers, and the perspective of potential simplifications and optimizations we can make to our tooling. We’ll start with the human perspective.&lt;/p&gt;

&lt;h3 id=&quot;continuation-only-mental-model&quot;&gt;Continuation-only: Mental model&lt;/h3&gt;

&lt;p&gt;Enforcing the constraint &lt;em&gt;continuation-only&lt;/em&gt; makes for a much more simple mental model of the nodes and histories under consideration than the alternative.&lt;/p&gt;

&lt;p&gt;To see why this is the case, consider the following: One of the reasons &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; is a separate operation in the first place is that it allows for a &lt;a href=&quot;/t-indices/&quot;&gt;semantics of identity in the face of change&lt;/a&gt;. In particular: we can talk about the node which is “replaced” as a single thing which exists over time, interpreting the &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; as a change to its current value and history, but not to its fundamental identity.&lt;/p&gt;

&lt;p&gt;The constraint &lt;em&gt;continuation-only&lt;/em&gt; fits nicely into that model. If the constraint applies, the node to which we attach this identity has a single linear history. At times, new things may happen in that history, but those things that have once happened will never “unhappen”.&lt;/p&gt;

&lt;p&gt;This mental model also maps quite nicely to a typical use case: that of editing a document. Each time a part of the document is edited, that part’s history is simply extended with the edit-operation.&lt;/p&gt;

&lt;p&gt;Contrast this model with the alternative, being  &lt;em&gt;any_history&lt;/em&gt;. In that scenario, each time a node is replaced, its history may be arbitrarily rewritten.&lt;/p&gt;

&lt;p&gt;In such a scenario we cannot speak of &lt;em&gt;the&lt;/em&gt; history of any of our children, since the view of what that history is may itself change over time. Because of that, we must, for each of a node’s children, distinguish between one of two different histories:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The history &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; as set in the latest &lt;code class=&quot;highlighter-rouge&quot;&gt;Insert&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; for the child.&lt;/li&gt;
  &lt;li&gt;The history of such histories.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Such a distinction makes reasoning about a node and the histories of its subnodes quite a bit more complex!&lt;/p&gt;

&lt;h3 id=&quot;continuation-only-t-paths&quot;&gt;Continuation-only: T-paths&lt;/h3&gt;

&lt;p&gt;In an editor which takes operations of change as its primitives we get the ability to reference the children of any given node by their order of appearance “for free”. This is quite useful, because such a reference will keep pointing at the same child over time. This was discussed in depth in &lt;a href=&quot;/t-indices/&quot;&gt;a separate article&lt;/a&gt;, in which we called such references &lt;em&gt;t-indices&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In that article we also mentioned &lt;em&gt;t-paths&lt;/em&gt;. The interpretation of such a &lt;em&gt;t-path&lt;/em&gt; is to consider it to be a list of &lt;em&gt;t-indices&lt;/em&gt;; to follow the path means to consider the elements of the path one by one and descend into the relevant child accordingly. As such a &lt;em&gt;t-path&lt;/em&gt; can point to an arbitrary descendant, not just a child.&lt;/p&gt;

&lt;p&gt;The possible utility of both &lt;em&gt;t-indices&lt;/em&gt; and &lt;em&gt;t-paths&lt;/em&gt; lies in the fact that, for some structure, they give us a reference to a descendant that keeps pointing at “the same” descendant in the face of changes to the structure over time. We could say that it is this utility that makes it so that the &lt;em&gt;t-index&lt;/em&gt; or &lt;em&gt;t-path&lt;/em&gt; does what you expect.&lt;/p&gt;

&lt;p&gt;For &lt;em&gt;t-indices&lt;/em&gt;, whether they do what you’d expect holds for both the cases &lt;em&gt;continuation-only&lt;/em&gt; and &lt;em&gt;any-history&lt;/em&gt;. This is because, in a single node with a single linear history, the assignment of t-indices to its children is only influenced by the occurrences of &lt;code class=&quot;highlighter-rouge&quot;&gt;Insert&lt;/code&gt; in that history. The interpretation of the attribute &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; of any given &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; operation does not come into play at all. By extension, neither does any constraint on &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt;’s arguments.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;T-paths&lt;/em&gt;, however, only do what you expect for the case &lt;em&gt;continuation-only&lt;/em&gt;. This is perhaps best shown with a counter-example. Consider again the history as provided at the beginning of this article of an &lt;em&gt;any-history&lt;/em&gt;, which is shown here annotated with the resulting &lt;em&gt;t-paths&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 ...&lt;/code&gt; –  inserts a new node at &lt;code class=&quot;highlighter-rouge&quot;&gt;t-index = 0&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 (BecomeAtom *))&lt;/code&gt;  –  resulting &lt;em&gt;t-path:&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;0 0&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 1 (BecomeAtom 6))&lt;/code&gt;  –  resulting &lt;em&gt;t-path:&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;0 1&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Replace 0 ...&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 (BecomeAtom +))&lt;/code&gt;  –  resulting &lt;em&gt;t-path:&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;0 0&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As should be obvious from the above, the &lt;em&gt;t-path&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;0 0&lt;/code&gt; does not constitute a meaningful reference to a node with a single identity: it initially points at the atom &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;, and later at the atom &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;, despite these two nodes being unrelated entirely: they exist in separate histories.&lt;/p&gt;

&lt;p&gt;When the constraint &lt;em&gt;continuation-only&lt;/em&gt; applies, it is not possible to construct such a counter-example: in that scenario it is not possible to replace a history with an entirely unrelated one by definition.&lt;/p&gt;

&lt;h3 id=&quot;algorithms&quot;&gt;Algorithms&lt;/h3&gt;

&lt;p&gt;Further consequences &lt;em&gt;continuation-only&lt;/em&gt; may be found in the algorithms that make use of histories of operations.&lt;/p&gt;

&lt;p&gt;What could such algorithms be? First, there is the algorithm that constructs an actual s-expression out of a history of changes – something we will inevitably be interested in at some point. When compared to an editor that stores s-expressions directly, such an algorithm forms a computational overhead by default. If only for that reason, it is worthwhile to consider its performance characteristics.&lt;/p&gt;

&lt;p&gt;First, let’s consider a naive implementation: For each &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; operation, construct the resulting structure from scratch by considering each element of the history in turn. Such an approach is not scalable: Each &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; operation takes a full history as one of its parameters and such histories grow linearly in time. Moreover, the histories are recursively composed of further &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; operations. The result is an exponential growth of the required runtime.&lt;/p&gt;

&lt;p&gt;A less naive approach is the following: make use of the fact that each &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; operations replaces an already existing node, which already has some structure. If we can use this existing structure in such a way that we don’t have to consider the full provided history each time we replace, we may reduce the required runtime considerably.&lt;/p&gt;

&lt;p&gt;If &lt;em&gt;continuation-only&lt;/em&gt; applies, this is quite straightforward: we can simply take the existing structure as our starting point, and apply to it only those operations in &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; that are new. Such an approach is only linear in time with the amount of new operations.&lt;/p&gt;

&lt;h2 id=&quot;any-history-1&quot;&gt;&lt;em&gt;any-history&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Finally, let’s considert the respective drawbacks and advantages of the alternative to &lt;em&gt;continuation-only&lt;/em&gt;, namely those of &lt;em&gt;any-history&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The drawbacks should be obvious: they are precisely the inverse of the aformentioned advantages. In particular: the mental model of what &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; means becomes more complex; arbitrary descendants may no longer be referenced meaningfully using a &lt;em&gt;t-path&lt;/em&gt; and performant algorithms for construction of nodes are less obvious.&lt;/p&gt;

&lt;p&gt;Having said that, there is still something to be said for this approach: Relaxing the constraint gives us certain features almost by definition. Namely: the ability to rewrite the histories of children-nodes, while retaining, at the level at which the rewriting is done, a reference to the history as it existed before it was rewritten. This means we get both the advantages of rewriting of history (cleaner histories) and those of never rewriting history (no loss of information).&lt;/p&gt;

&lt;p&gt;To see how this is so, consider the example with which we started this article:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 ...&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 (BecomeAtom *))&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 1 (BecomeAtom 6))&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Replace 0 ...&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 (BecomeAtom +))&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the above, from the perspective of the node whose history is rewritten, all that ever happened is the insertion of the atom &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;. However, from the root node we can still see that at some point there was a different history for that node.&lt;/p&gt;

&lt;p&gt;Note that this ability to rewrite history is &lt;em&gt;integrated&lt;/em&gt; into our main means of expression: we do not require a separate layer of abstraction for it. One caveat does apply though: it is only available on items that are at least one level lower in the tree. This also implies that rewriting history is not available for the root of the tree.&lt;/p&gt;

&lt;p&gt;It remains to be seen whether this integrated approach to rewriting of history should be seen as a useful means of expression, or an undesirable conflation of ideas.&lt;/p&gt;

&lt;h3 id=&quot;meaningful-rewrites&quot;&gt;Meaningful rewrites&lt;/h3&gt;

&lt;p&gt;That rewriting history is useful in the first place should perhaps be made clear with a separate example.&lt;/p&gt;

&lt;p&gt;The running example of &lt;em&gt;any-rewrite&lt;/em&gt; has been to present a rewriting of history that is truly arbitrary: in the example above there is truly no relationship between the history pre and post rewrite.&lt;/p&gt;

&lt;p&gt;In practice, rewriting of history will often not be so arbitrary. For an example of this, consider the concept of &lt;em&gt;undo&lt;/em&gt;, which can be modeled by replacing the history of a node by a history in which the last operation is no longer present:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 ...&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 (BecomeAtom *))&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 1 (BecomeAtom 6))&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 2 (BecomeAtom 9))&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Replace 0 ...&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 (BecomeAtom *))&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 1 (BecomeAtom 6))&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;conclusions--final-thoughts&quot;&gt;Conclusions / final thoughts&lt;/h3&gt;

&lt;p&gt;In the above we’ve seen the respective advantages and disadvantages of either enforcing the constraint that histories must be append-only or not. A few final thoughts are below.&lt;/p&gt;

&lt;p&gt;First, as noted in the above, a naive approach to &lt;em&gt;t-paths&lt;/em&gt; does not yield meaningful results. It is however, even in environments in which nodes can be replaced by arbitrary histories, possible to come up with a scheme of referencing children that does in fact yield meaningful references across time. This scheme will be explained in a future article.&lt;/p&gt;

&lt;p&gt;Second, we noted that in &lt;em&gt;continuation-only&lt;/em&gt; a performant algorithm for construction is readily available, whereas for for &lt;em&gt;any-history&lt;/em&gt; it is not as obvious what such an algorithm should look like. We simply postulate here that such algorithms can still be devised. In particular it is possible to come up with algorithms that are linear in runtime with respect to the amount of history-rewriting.&lt;/p&gt;

&lt;p&gt;Finally: given the above advantages and disadvantages, we are left with a question: should we apply the constraint or not?  Or should we perhaps make a distinction between environments in which the constraint applies, and environments in which it doesn’t? Or should we perhaps have 2 distinct operations for &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt;, one for each scenario?&lt;/p&gt;

&lt;p&gt;These are, as it stands, open questions. The present version of the edtior is &lt;em&gt;any-history&lt;/em&gt;. The rationale is: this forces me to think about the annoying corner-cases which exist only if the constraint does not apply. However, this is certainly subject to change.&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/constraints-on-replace/&quot;&gt;Constraints on Replace&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on November 14, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[T-Indices]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/t-indices/" />
  <id>http://expressionsofchange.com/t-indices</id>
  <published>2017-11-09T00:00:00+01:00</published>
  <updated>2017-11-09T00:00:00+01:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;p&gt;Let’s start with some terminology.&lt;/p&gt;

&lt;p&gt;An &lt;a href=&quot;https://en.wikipedia.org/wiki/S-expression&quot;&gt;s-expression&lt;/a&gt; is a notation for tree-structured data. Each s-expression is either an atom or a list of s-expressions. Using this recursive definition arbitrary tree-structures can be formed.&lt;/p&gt;

&lt;p&gt;Because it is the tree-like properties that we’re interested in in this article, we will use the terminology of trees (nodes, children, parents) in the below. We will mostly ignore atoms and talk almost exclusively of list-expressions, as these are the only non-trivial case, being the only type of node that can have children.&lt;/p&gt;

&lt;p&gt;If we want to talk about a particular child of a node, a straightforward way of doing so is to reference it by its &lt;a href=&quot;https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html&quot;&gt;zero-based&lt;/a&gt; index in the list of children. I.e. in s-expression &lt;code class=&quot;highlighter-rouge&quot;&gt;(a b)&lt;/code&gt; we can say that the atom &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; is the child at index &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, and the atom &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; is the child at index &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This observation can be generalized to refer to descendants at arbitrary depth by using a list of such indices and interpreting it as a path through the tree. I.e. in the s-expression &lt;code class=&quot;highlighter-rouge&quot;&gt;(a (b ((c d) e)))&lt;/code&gt; the atom &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; can be reached by following the path &lt;code class=&quot;highlighter-rouge&quot;&gt;1, 1, 0, 0&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this approach we use the &lt;em&gt;spatial&lt;/em&gt; layout of the tree-structure to refer to its elements. It is for this reason that we will refer to such indices as &lt;em&gt;s-indices&lt;/em&gt; in the below.&lt;/p&gt;

&lt;h3 id=&quot;t-indices&quot;&gt;T-indices&lt;/h3&gt;

&lt;p&gt;In the editor presented in this project we &lt;a href=&quot;...&quot;&gt;treat the modifications to s-expressions as first level citizens&lt;/a&gt;. The central motivation for doing this is the idea that changes to computer programs are such a central aspect of the programming experience that they must be put more centrally in the tooling.&lt;/p&gt;

&lt;p&gt;We do this by offering a small set of operations for constructing s-expressions, and storing those means of construction rather than the constructed structures. Key elements of this set of operations are &lt;code class=&quot;highlighter-rouge&quot;&gt;Insert&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Delete&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Given these operations, a second way of referring to the children of a node becomes available: by referring to them in their order of appearance. In other words: when were they inserted?&lt;/p&gt;

&lt;p&gt;Consider the following full history of operations on a list node:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Insert &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; at s-index 0.&lt;/li&gt;
  &lt;li&gt;Insert &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; at s-index 0.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Constructing a node using these operations will yield the expression &lt;code class=&quot;highlighter-rouge&quot;&gt;(a b)&lt;/code&gt;, given that insertion at a given s-index will shift any items at or above that s-index one place to the right&lt;/p&gt;

&lt;p&gt;In a such constructed node, we may refer to the node &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; as created at &lt;em&gt;t=0&lt;/em&gt; and the node &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; as created at &lt;em&gt;t=1&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Because we we look at the node through the lens of &lt;em&gt;time&lt;/em&gt; as opposed to its current &lt;em&gt;spatial&lt;/em&gt; layout in this approach, we’ll denote this indexing scheme as the &lt;em&gt;t-index&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Note that the same generalization to paths to arbitrary descendants is available for t-indices as it was in the case of regular indices, &lt;a href=&quot;/constraints-on-replace/&quot;&gt;although some constraints must apply on replace’s paramters for the path to be stable over time&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;delete&quot;&gt;Delete&lt;/h4&gt;

&lt;p&gt;Referring to children in order of insertion raises the question: how does this interact with some of the other main operations, namely &lt;code class=&quot;highlighter-rouge&quot;&gt;Delete&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;The answer for &lt;code class=&quot;highlighter-rouge&quot;&gt;Delete&lt;/code&gt; is straightforward: deleting a child makes it go away in the current version, but does not alter the order of appearance. Consider the following full history of a node:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Insert &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; at s-index 0.&lt;/li&gt;
  &lt;li&gt;Insert &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; at s-index 0.&lt;/li&gt;
  &lt;li&gt;Delete the item at s-index 1.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Constructing a node using these operations yields an expression &lt;code class=&quot;highlighter-rouge&quot;&gt;(a)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;At t-index 1 we still have the node &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;, as in the previous example. At t-index 0, however, we now have nothing. This is because the child &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;, which lived at (spatial) index 1 at the time of deletion, was the item at t-index 0. Such an answer “nothing” may be implemented using a special &lt;em&gt;tombstone&lt;/em&gt; or &lt;em&gt;sentinel&lt;/em&gt; value.&lt;/p&gt;

&lt;h4 id=&quot;replace&quot;&gt;Replace&lt;/h4&gt;

&lt;p&gt;How &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; operations affect t-indices is less straightforward – in the design of the editor, one actually has to make a choice between one of 2 options.&lt;/p&gt;

&lt;p&gt;As a first attempt, we could simply view Replace as a shorthand for a &lt;code class=&quot;highlighter-rouge&quot;&gt;Delete&lt;/code&gt; followed by and &lt;code class=&quot;highlighter-rouge&quot;&gt;Insert&lt;/code&gt;. In that model, after a replace, the t-index previously pointing to the now-replaced child will yield the &lt;em&gt;tombstone&lt;/em&gt;, and the new value for the child will be associated with a new consecutive t-index. Considering the following example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Insert &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; at s-index 0.&lt;/li&gt;
  &lt;li&gt;Insert &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; at s-index 0.&lt;/li&gt;
  &lt;li&gt;Replace the item at s-index 1 with &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The t-index 0 would, just like in the example for Delete, yield no result. The t-index 2 would point to the child &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A second possible definition for the interplay between &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; and t-indices is quite different: In it, the t-index of the replaced child is reused to point to the new child after the replacement.&lt;/p&gt;

&lt;p&gt;In this definition, after the same set of operation as in the last example, the t-index 0 points to the item &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; and the t-index 2 is as of yet unused.&lt;/p&gt;

&lt;p&gt;As such, we can use the t-index to answer the question “what is the child that was &lt;em&gt;nth&lt;/em&gt; element in the order of insertion, and may since have been changed any number of times?”. This means that we can use t-indices as a reference &lt;a href=&quot;/ship-of-theseus/&quot;&gt;to an identity that persists under mutation&lt;/a&gt;. In this model the identity is formed at insertion, and replace is interpreted as a mutation that does not alter identity.&lt;/p&gt;

&lt;p&gt;Note that in this model, in cases where modeling identity persisting across a replace is undesirable, we always have the option of explicitly deleting and inserting instead.&lt;/p&gt;

&lt;p&gt;It is this second definition that we have taken in the editor.&lt;/p&gt;

&lt;h3 id=&quot;uses-for-t-indices-in-the-ui&quot;&gt;Uses for t-indices in the UI&lt;/h3&gt;

&lt;p&gt;Associating an identity with nodes on the moment of their creation, and having a simple way (namely: consecutive numbers) to refer to them is useful in a number of ways.&lt;/p&gt;

&lt;p&gt;A first such use case is in presenting historical views to the user. Consider again the following 3 operations:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Insert &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; at s-index 0.&lt;/li&gt;
  &lt;li&gt;Insert &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; at s-index 0.&lt;/li&gt;
  &lt;li&gt;Delete the item at s-index 1.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It is not immediately obvious that the deletion operates on the item &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;, which has since its creation been shifted to s-index 1 because another item was inserted in its place. This is the case even for this trivial example; in any non-trivial example this lack of clarity renders historical views which only display an s-index quite useless from a UI perspective.&lt;/p&gt;

&lt;p&gt;To remedy this, we can use t-indices in our UI, and decorate the above to the show the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Insert &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; at s-index 0, yielding t-address 0.&lt;/li&gt;
  &lt;li&gt;Insert &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; at s-index 0, yielding t-address 1.&lt;/li&gt;
  &lt;li&gt;Delete the item at s-index 1 (which is t-address 0)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Of course, in an actual UI we are not restricted to such a rather clumsy textual notation. Instead, we could e.g. use colors to highlight the relationships between various operations at the same t-address.&lt;sup id=&quot;fnref:t-addresses-everywhere-is-not-possible&quot;&gt;&lt;a href=&quot;#fn:t-addresses-everywhere-is-not-possible&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;The idea of a node having an persistent identity in the context of changes to its value is useful more generally. One example is in an interface which has multiple views on a single document, e.g. in the form of multiple tabs or windows. In such a setup one can imagine certain windows displaying part of a larger tree; and edits to this part of the tree being consistently propagated from and to other windows that show the same part of the tree. The idea of sameness can then be modeled using t-paths.&lt;/p&gt;

&lt;p&gt;In particular, this means one can edit part of a tree in one separate window, without any possible confusion as to what it means if that part is moved around in the document. (Such moving around may occur as a result of insertions and deletions in its parent node). In cases where the editor has only a single user and a single thread of control, such confusion is ruled out entirely. In distributed and multi-user contexts we are able to significantly reduce the amount of such confusion (“merge conflicts”); more about which in a separate article.&lt;/p&gt;

&lt;h3 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h3&gt;

&lt;p&gt;T-indices, and by extension t-paths, are a useful tool to unambiguously talk about a particular node in a mutable tree.&lt;/p&gt;

&lt;p&gt;They require a historical view of the tree, but given such a view are quite trivially implemented.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:t-addresses-everywhere-is-not-possible&quot;&gt;
      &lt;p&gt;One might be tempted to take t-addresses as the basis of modeling of the 3 operations if it is indeed a useful representation. Note however that for insertions we always need the s-address, and hence such a model would lead to an inconsistant mix of s-addresses and t-addresses in the operations. &lt;a href=&quot;#fnref:t-addresses-everywhere-is-not-possible&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;

  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/t-indices/&quot;&gt;T-Indices&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on November 09, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Git is ignorant by design]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/git-is-ignorant-by-design/" />
  <id>http://expressionsofchange.com/git-is-ignorant-by-design</id>
  <published>2017-11-08T00:00:00+01:00</published>
  <updated>2017-11-08T00:00:00+01:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;h3 id=&quot;an-example&quot;&gt;An example&lt;/h3&gt;

&lt;p&gt;The concept is best explained using an example. Consider the following output of &lt;code class=&quot;highlighter-rouge&quot;&gt;git show&lt;/code&gt;, which shows a change to a piece of Python code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;commit 9dadc2.........
Author: ......
Date: ......

    Refactoring: move method_c and method_d
    
    These methods are moved from OneClass to AnotherClass, as the latter
    is the correct location because of some reasons that would certainly
    exist if this wasn&#39;t a toy example.

&lt;span class=&quot;gh&quot;&gt;diff --git a/example.py b/example.py
index 1cde8fb..f487c7e 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/example.py
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/example.py
&lt;/span&gt;&lt;span class=&quot;gu&quot;&gt;@@ -2,17 +2,17 @@ class AnotherClass(object):
&lt;/span&gt;     def method_a(self):
         pass  # implementation of method_a ...
 
&lt;span class=&quot;gd&quot;&gt;-
-class OneClass(object):
-    def method_b(self):
-        pass  # implementation of method_b ...
-
&lt;/span&gt;     def method_c(self):
         pass  # implementation of method_c ...
 
     def method_d(self):
         pass  # implementation of method_d ...
 
&lt;span class=&quot;gi&quot;&gt;+
+class OneClass(object):
+    def method_b(self):
+        pass  # implementation of method_b ...
+
&lt;/span&gt;     def method_e(self):
         pass  # implementation of method_e
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;How should we interpret this diff?&lt;/p&gt;

&lt;p&gt;Let’s start by reading what the author ostensibly intended. The commit message talks about moving the two methods &lt;code class=&quot;highlighter-rouge&quot;&gt;method_c&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;method_d&lt;/code&gt; from &lt;code class=&quot;highlighter-rouge&quot;&gt;OneClass&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;AnotherClass&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;However, if we look at the actual diff, we see something else entirely: the removal of the definition of &lt;code class=&quot;highlighter-rouge&quot;&gt;OneClass&lt;/code&gt; and its method &lt;code class=&quot;highlighter-rouge&quot;&gt;method_b&lt;/code&gt; in one place, and the reintroduction of these elements in another place.&lt;/p&gt;

&lt;p&gt;It might seem that either the commit message or the actual contents of the commit are wrong. It turns out that neither is the case. Instead, the source of confusion lies in the way &lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt; works&lt;sup id=&quot;fnref:or-any-text-based-vcs&quot;&gt;&lt;a href=&quot;#fn:or-any-text-based-vcs&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h3 id=&quot;snapshots-on-text-files&quot;&gt;Snapshots on text files&lt;/h3&gt;

&lt;p&gt;Git views the world as a collection of files (usually: text files), of which snapshots are made each time a commit is made. This means that, for the example above, &lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt; got to see the following two versions:&lt;/p&gt;

&lt;h4 id=&quot;before-the-commit&quot;&gt;Before the commit:&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnotherClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;method_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# implementation of method_a ...&lt;/span&gt;
 

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OneClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;method_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# implementation of method_b ...&lt;/span&gt;

     &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;method_c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# implementation of method_c ...&lt;/span&gt;
 
     &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;method_d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# implementation of method_d ...&lt;/span&gt;
 
     &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;method_e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# implementation of method_e&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;after-the-commit&quot;&gt;After the commit:&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnotherClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;method_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
             &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# implementation of method_a ...&lt;/span&gt;
     
         &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;method_c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
             &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# implementation of method_c ...&lt;/span&gt;
     
         &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;method_d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
             &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# implementation of method_d ...&lt;/span&gt;
     

    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OneClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;method_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# implementation of method_b ...&lt;/span&gt;

         &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;method_e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
             &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# implementation of method_e&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;First note that these 2 versions actually correspond to the commit message: the 2 methods &lt;code class=&quot;highlighter-rouge&quot;&gt;method_c&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;method_d&lt;/code&gt; are indeed moved from &lt;code class=&quot;highlighter-rouge&quot;&gt;OneClass&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;AnotherClass&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, why does &lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt; present a diff that seems to tell a different story? To answer this, we must first understand what &lt;code class=&quot;highlighter-rouge&quot;&gt;git diff&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;git show&lt;/code&gt; do in the first place: Given two versions of a file these commands attempt to calculate the smallest difference between them and present this.&lt;/p&gt;

&lt;p&gt;Regarding the meaning of the content of the files Git makes only a very minimal number of assumptions. Most of these have to do with “plain text files”. For example, it knows the special meaning of newline-characters. Using this knowledge the goal of finding a minimal difference is interpreted to mean “with a minimal number of different lines”.&lt;/p&gt;

&lt;p&gt;Given these goals, the diff as presented in the original example is exactly what you’d expect: removing &lt;code class=&quot;highlighter-rouge&quot;&gt;OneClass&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;method_b&lt;/code&gt; in one place and adding them in another is simply more efficient than the alternative of removing and adding &lt;code class=&quot;highlighter-rouge&quot;&gt;method_c&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;method_d&lt;/code&gt;. The former affects 5 removed lines and 5 added lines for a total of 10 while the latter affects 2 × 6 = 12 lines. (In both cases empty lines contribute to the numbers). Given that &lt;em&gt;Git&lt;/em&gt; attempts to show the smallest diff, it prefers the former options over the latter.&lt;/p&gt;

&lt;h3 id=&quot;the-problem-defined&quot;&gt;The problem defined&lt;/h3&gt;

&lt;p&gt;Given that &lt;code class=&quot;highlighter-rouge&quot;&gt;git diff&lt;/code&gt; behaves according to specification, what’s the problem? Can we make the suggestion that the original example is confusing more precise? In fact we can!&lt;/p&gt;

&lt;p&gt;The key to this is in realizing the following: Our example deals with a piece of Python code, in which concepts such as “classes” and “methods” exist. These concepts have a hierarchical nature: classes are structures that may contain other structures such as methods. When editing the file, we are aware of this structure – in fact, it forms the very reason we edit the file, an intent that the author even captured in the commit message.&lt;/p&gt;

&lt;p&gt;Moving part of a hierarchical structure to a different container is quite a useful and natural thing to be able to express. For comparison, consider the following phrases: “moving files to another directory” and “moving marbles to a different vase”.  Contrast this with the unnatural alternative of saying that the containers have, so to speak, “wrapped around newly contained items”: We don’t usually say “we’ve moved a directory-ending somewhat, so that it now contains 3 more files”, nor do we say “a vase has been moved to a location where it happens to contain more marbles”.&lt;/p&gt;

&lt;p&gt;Git, however, occasionally does precisely that, as demonstrated in the original example: it moves a class definition relative to its contents rather than vice versa.&lt;/p&gt;

&lt;p&gt;This is because Git remains agnostic of the structure of the files under its control, noting only that they are text files. Given that it can simply do no better than calculating the smallest difference in number of changed lines. This smallest number of lines happens to include the class definition, rather than the lower-level methods contained therein.&lt;/p&gt;

&lt;p&gt;It is for this reason that we can say “Git is &lt;em&gt;ignorant&lt;/em&gt;” – it’s ignorant of the structure of the files it’s diffing.&lt;/p&gt;

&lt;h3 id=&quot;closing-remarks&quot;&gt;Closing remarks&lt;/h3&gt;

&lt;p&gt;This concludes the main discussion of the problem. Some final thoughts are below.&lt;/p&gt;

&lt;p&gt;First, one might wonder how serious of a problem this really is. On this I can only speak from personal experience: I personally run into some version of this problem approximately once a week. Admittedly, the most regular occurrences are also less confusing than the example at the top of this article, which was contrived specifically to be maximally confusing.&lt;/p&gt;

&lt;p&gt;A more regular occurrence is a diff like the below:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gd&quot;&gt;--- a/example.py
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/example.py
&lt;/span&gt;&lt;span class=&quot;gu&quot;&gt;@@ -1,3 +1,8 @@
&lt;/span&gt; @decorated_function
&lt;span class=&quot;gi&quot;&gt;+def newfunction():
+    pass  # this is newfunction
+
+
+@decorated_function
&lt;/span&gt; def oldfunction():
     pass  # this is oldfunction
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In the above example, the more logical diff would identify the first of the 2 decorators (&lt;code class=&quot;highlighter-rouge&quot;&gt;@decorated_function&lt;/code&gt;) as being the newly added one. However, git cannot distinguish between the 2 identical occurrences of that line, and identifies the second one as the new one.&lt;/p&gt;

&lt;p&gt;If we read this diff like a story, git seems to tell us the following: the decorator of the function &lt;code class=&quot;highlighter-rouge&quot;&gt;oldfunction&lt;/code&gt; was repurposed for a newly added function &lt;code class=&quot;highlighter-rouge&quot;&gt;newfunction&lt;/code&gt;. The function &lt;code class=&quot;highlighter-rouge&quot;&gt;oldfunction&lt;/code&gt; was then given a new (identical) decorator to compensate for its loss. A simpler and more correct story would be: a new function &lt;code class=&quot;highlighter-rouge&quot;&gt;newfunction&lt;/code&gt; was added with its own decorator.&lt;/p&gt;

&lt;p&gt;A final example uses lists, in which it would be more logical to show the earlier opening bracket as the new addition. Such an approach would lead to a diff with balanced brackets, as opposed to the close-then-open we get now:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gd&quot;&gt;--- a/matrix.py
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/matrix.py
&lt;/span&gt;&lt;span class=&quot;gu&quot;&gt;@@ -5,6 +5,11 @@ matrix = [
&lt;/span&gt;         3,
     ],
     [
&lt;span class=&quot;gi&quot;&gt;+        7,
+        8,
+        9,
+    ],
+    [
&lt;/span&gt;         4,
         5,
         6,
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In short: examples of the problem are easily found. However: the most regular occurrences are also generally the least confusing.&lt;/p&gt;

&lt;p&gt;As of yet, I have not been able to find other people reporting a similar experience. Whether this is because others don’t experience this phenomenon as a problem, or whether they have resigned themselves to Git’s set of assumptions, I do not know. You are invited let me know, possibly by presenting any of your own real-life examples in the comment section below.&lt;/p&gt;

&lt;h3 id=&quot;heuristics-and-fundamental-solutions&quot;&gt;Heuristics and fundamental solutions&lt;/h3&gt;

&lt;p&gt;As noted in the above, git’s ignorance is a fundamentally unsolvable problem: diffs that are based on text alone can never fundamentally know what the underlying structures of those text files were. This does not mean that finding better heuristics for presenting diffs is entirely impossible.&lt;/p&gt;

&lt;p&gt;The option &lt;code class=&quot;highlighter-rouge&quot;&gt;--indent-heuristic&lt;/code&gt;, introduced in Git version 2.11, attempts to do just that: it uses indentation as a heuristic for hierarchical structure; this corresponds to the reality in many programming languages and data formats.&lt;/p&gt;

&lt;p&gt;However, for obvious reasons, a solution using heuristics can only lead to limited results. Thoughts on more fundamental solutions which require no heuristics at all are the subject of the rest of this website.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:or-any-text-based-vcs&quot;&gt;
      &lt;p&gt;Git, being the most popular Version Control System, is singled out here; most remarks in this article apply in fact to any modern VCS that ignores the underlying structure of the (text) files under its control. &lt;a href=&quot;#fnref:or-any-text-based-vcs&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;

  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/git-is-ignorant-by-design/&quot;&gt;Git is ignorant by design&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on November 08, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[September status update]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/september-status-update/" />
  <id>http://expressionsofchange.com/september-status-update</id>
  <published>2017-09-12T00:00:00+02:00</published>
  <updated>2017-09-12T00:00:00+02:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;p&gt;Given the fact that it’s been a bit quiet on this website for the past few months, I figured it was time for a short status update.&lt;/p&gt;

&lt;p&gt;In this project I experiment with better tooling for constructing ever-changing computer programs. The project is split into 2 major related parts: an editor in which changes take a central role, and the interpretation of artifacts as produced by the editor as computer programs.&lt;/p&gt;

&lt;p&gt;I have decided to let the editor be for now, and have recently switched my attention to working on a small Lisp interpreter. This takes as its input a mechanism of construction of an S-Expression, rather than just the constructed end-product.&lt;/p&gt;

&lt;p&gt;As some key parts of the modelling I have identified:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A small set of Lisp forms&lt;/li&gt;
  &lt;li&gt;A vocabulary of change on these forms (A “&lt;em&gt;Clef&lt;/em&gt;”).&lt;/li&gt;
  &lt;li&gt;A mapping of changes to S-Expressions to changes to Lisp forms.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The above is (roughly) implemented.&lt;/p&gt;

&lt;p&gt;The current step is to make sure the Lisp forms lead to an actually functioning interpreter. Doing so as a prototype should, hopefully, be fairly simple.&lt;/p&gt;

&lt;p&gt;An important goal in the implementation of this interpreter is to stay faithful to the notion of expressions of change. In particular: rather than interpret fully constructed programs, the focus is in interpreting the meaning of changes to existing programs.&lt;/p&gt;

&lt;p&gt;A related goal is to express certain kinds of program analysis in terms of analyses to changes to programs. (“incremental analysis”)&lt;/p&gt;

&lt;p&gt;Some candidates for such analyses are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Analysing variable usage &amp;amp; binding incrementally. By doing so we improve the programmer experience from “this variable is undefined” to “this variable became undefined at such and such edit operation” and similarly for “this variable is unused” and “this variable shadows another variable”.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Static type-analyses may similarly be formulated incremtally.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Stay tuned for further updates.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/september-status-update/&quot;&gt;September status update&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on September 12, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Ship of Theseus]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/ship-of-theseus/" />
  <id>http://expressionsofchange.com/ship-of-theseus</id>
  <published>2017-07-12T00:00:00+02:00</published>
  <updated>2017-07-12T00:00:00+02:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;p&gt;In the original form of the riddle the mythological hero &lt;a href=&quot;https://en.wikipedia.org/wiki/Theseus&quot;&gt;Theseus&lt;/a&gt; returns to Athens on a ship after defeating a monster, the Minotaur.  After his return, the Athenians preserve his ship for many centuries so that it may serve a role in religious ceremonies. Over the years they replace the planks one by one as they are affected by rot.&lt;/p&gt;

&lt;p&gt;The puzzle is: at some point all planks of the ship have been replaced. Is it still the same ship as before? Is it still Theseus ship?&lt;/p&gt;

&lt;p&gt;The paradoxical nature of the thought experiment seems to arise as such: Repairing objects, in this case by replacing a single plank, does not fundamentally alter their identity. If the ship was Theseus ship before the repair, it clearly is Theseus ship after the repair too. After many such repairs however, the original ship and the ship with all planks replaced have nothing in common. How can two things that have nothing in common be the same? Is a thing not that out of which it consists?&lt;/p&gt;

&lt;p&gt;Before answering, consider a variation on the theme, as put forward by Thomas Hobbes:&lt;/p&gt;

&lt;p&gt;In Hobbes’ variation, we use the planks that are taken away from the original ship to construct a new ship. After all planks have been replaced, we have 2 ships: one which started out as the original, but had each plank replaced, and one which consists entirely of the original planks. Which of these ships is Theseus ship? If it is the newly constructed one, at which point is the identity transferred?&lt;/p&gt;

&lt;h2 id=&quot;potential-solutions&quot;&gt;Potential solutions&lt;/h2&gt;

&lt;p&gt;Since the Ship of Theseus is an ancient thought experiment, numerous solutions have been put forth over time. We explore some of them and their ramifications below.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;A thing is (exclusively) its parts&lt;/strong&gt; — in this solution, the ship of Theseus is exclusively the planks out of which it was originally made. In the original version, by replacing the planks, the ship slowly dissolves over time. After 40% of the planks have been replaced, we can only speak of the “60% ship of Theseus”. In Hobbes’ version, the second ship slowly assumes the identity of Theseus ship over time. This solution is unsatisfying, if only for the fact that we don’t use such gradual notions of identity in day to day speech.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Threshold value&lt;/strong&gt; — we might instead consider setting some threshold number of planks that carry with it the identity.  The problem with this solution is that it seems quite hard to come up with a non-arbitrary such threshold, that can be applied across various sorts of objects. It is quite easy to come up with new variants of the riddle that make this evident. For example: what if we distribute the planks from the original ship over 5 new ships?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Reject identity in the face of change&lt;/strong&gt; — having seen two failed approaches, we might reject the idea of persistent identity in the face of change altogether. Each time a plank is replaced, we end up with a fully new ship, the previous one having been destroyed. The problem with this solution is that it’s not a solution at all: it simply amounts to giving up in the face of a seemingly hard problem. As a consequence, we lose the ability to meaningfully talk about identity in the face of change.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;4-dimensionalism&lt;/strong&gt; — in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Perdurantism&quot;&gt;4-dimenionalist&lt;/a&gt; view we say that Theseus ship is an object that exists across 3 spatial dimensions and 1 dimension of time. In this view the ship before and after the replacement of the planks are 3 dimensional slices of the 4-dimensional object which extends across time. This solution works for the original problem, but it’s not immediately clear how it answers the further complications as proposed by Hobbes: it does help us answer which of the 2 ships is the ship of Theseus.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;“Semantics”&lt;/strong&gt; — finally, we might say that the mistake is in assigning identity to objects in the first place. In this view, identity is simply a definition given in language by people to objects, but no property of the object itself. Asking questions about the object’s identity as if it is, as we do in the riddle, is nonsensical. In other words: the ship of Theseus is simply that what we call the ship of Theseus, or what the Athenians deem to be it, or even just the ship that is currently legally owned by Theseus. This solution seems to be the most useful, but by saying that it’s all just semantics, it’s also somewhat dismissive of how such semantics may come to be. By carefully examining the original puzzle we can point at the introduction of such semantics.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;revisiting-the-problem&quot;&gt;Revisiting the problem&lt;/h2&gt;

&lt;p&gt;In the setup of the puzzle, a ship is described, whose planks are replaced one by one. By this very formulation, an identity across time is implied: the thing whose planks are replaced is something we can talk about, all the way up the last plank. It is the formulation of the puzzle itself that creates the identity of the single ship, consisting of different planks over time.&lt;/p&gt;

&lt;p&gt;After this setup comes the trick: in the final line of the riddle we’re asked to consider the ship’s material form at two points in time, and question whether these are the same. The paradoxical nature of the riddle then arises from 2 sources:&lt;/p&gt;

&lt;p&gt;First, there’s the fact that the setup talks about the historical ship and the process of plank-replacing at length. By doing so, we imply that it is somehow relevant to the question at hand. But in the question at the end this historical context is ignored, and only the first and last form of the ship are presented, asking us to make a statement about these forms while precisely ignoring this historical context.&lt;/p&gt;

&lt;p&gt;(In cases where the riddle is presented as a video-animation, we can actually see this source of the confusion in the animation. In such videos the final part of the riddle is invariably modeled as the morphing of a long series of ships into 2 unequal instances of such ships)&lt;/p&gt;

&lt;p&gt;Second, and perhaps more to the point, there’s the fact that the forms of the ship at any given point in time are not distinguished from the identity of the ship across time, despite them being of an entirely different class.&lt;/p&gt;

&lt;p&gt;When such a distinction is properly made, the paradox disappears. We might ask then:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;is the form of the ship as it appears after the planks are replaced the same as before it? — no.&lt;/li&gt;
  &lt;li&gt;is the form of the ship at some point in time the same as the ship in all time? — no.&lt;/li&gt;
  &lt;li&gt;are both the forms of the ship before and after the planks have been replaced forms of the ship at some point in time? — yes.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Finallly, we might want to consider what to name this ship. In the above we established the existence of a single ship across time, as implied by the very phrasing of the riddle itself. Whether this single ship should be called the “ship of Theseus” is slightly less evident. We could argue it should be: At the beginning of the puzzle the puzzle speaks of the ship of Theseus, and since there is only one ship, there is no real ambiguity if we speak of the ship of Theseus by the end of the puzzle as well. If such lack of ambiguity is not sufficient to our taste, we could always speak of “the ship from the riddle” instead.&lt;/p&gt;

&lt;p&gt;Summarizing, the original riddle is only paradoxical because it defines a historical identity and then, in imprecise language, asks us whether certain ships are this historical identity. In the form of a Q &amp;amp; A:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Q&lt;/strong&gt;: “what is the ship of Theseus?”&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;A&lt;/strong&gt;: “didn’t you just tell me? it is the ship from the riddle!”&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hobbes&quot;&gt;Hobbes&lt;/h2&gt;

&lt;p&gt;The paradoxical nature of the Hobbes variation is caused by quite a different error in reasoning.&lt;/p&gt;

&lt;p&gt;Remember, in Hobbes’ version, the riddle does not describe a process of plank-replacing on a single ship. Instead, 2 ships are described, as well as a process of transferring planks from one to the other. After these descriptions, the question is put to us: “which of these is the ship of Theseus?”&lt;/p&gt;

&lt;p&gt;We are, in short, dealing with the opposite situation from the original problem. In the original, an definition (abeit implicitly) for was implicitly provided by the riddle; after which the riddle pretends this never happened. Here, the task of defining a single ship of Theseus is put squarely in our court.&lt;/p&gt;

&lt;p&gt;The problem is that, for each such definition, it’s quite possible to come up with arguments as to why this definition does not work well. This raises the question: why should we expect that it’s possible to come up with a meaningful such definition in the first place? The answer to this question would seem to be: because it was possible to do so in the original problem.&lt;/p&gt;

&lt;p&gt;However, in the original problem there was only a single ship, changing in form over time; in the Hobbes formulation there are multiple such ships.&lt;/p&gt;

&lt;p&gt;In other words: the Hobbes formulation is only paradoxical if you believe that, just because it is sometimes possible to come up with meaningful definitions, it is always possible to do so.&lt;/p&gt;

&lt;p&gt;In short:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Q&lt;/strong&gt;: “what is the ship of Theseus?”&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;A&lt;/strong&gt;: “why don’t &lt;em&gt;you&lt;/em&gt; tell me?”&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;Having examined the ship of Theseus in two variations we may ask ourselves what was actually achieved. Setting up a riddle, only to solve it by showing the errors of logic in the riddle itself surely smells of trickery. This is surely how some of the commentators on the videos floating around the internet about the subject feel (“Moot semantics”, “This is why I hate philosophy”, “Merely a matter of semantics, but it pays better to try and make a great deal out of it.”)&lt;/p&gt;

&lt;p&gt;One might counter that any problem once understood is trivial — including those that flow directly from bad definitions. In particular, the riddles and their solutions provide a number of useful insights when modeling the world, for example while writing computer programs.&lt;/p&gt;

&lt;p&gt;First, the semantics of identity as implied in the original puzzle, namely those of a single historical object which changes over time, are common and useful. Identifying it as a pattern is helpful.&lt;/p&gt;

&lt;p&gt;Second, errors such as the ones presented in the riddles above are extremely easy to make and common. Having a clear thought experiment available to us to clarify the error is useful.&lt;/p&gt;

&lt;p&gt;In fact, such confusion of semantics may happen any time we talk informally about mutable objects. Examples of those are everywhere in everyday computing: files, web pages, rows in databases, variables etc.&lt;/p&gt;

&lt;p&gt;Each time we talk about such a thing, we run into exactly the same problems of the original puzzle. Consider the question “is the file &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/passwords&lt;/code&gt; the same file as it was 10 minutes ago?” — and how it is phrased quite similarly to the original problem. This is the more pressing an issue, because in many cases the only thing our tools and languages allow us to talk about are the things across all of time. In HTML, for example, one may link to a web page, but there is no way to link to a particular version of a web page. In many programming languages, all variables are references to mutable objects.&lt;/p&gt;

&lt;p&gt;Third, the Hobbes variation tells us that it is not always immediately clear which defintion of historical identity is the most appropriate.&lt;br /&gt;
This also applies to the way we model the evolution of computer programs, such as we do in the project that this website is about.&lt;/p&gt;

&lt;p&gt;Examples of real-life changes to computer programs that may lead to direct parallels with Hobbes’ riddle are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;when splitting a single module into 2 modules, which of the 2 resulting modules (if any) has the same identity as the original?&lt;/li&gt;
  &lt;li&gt;when moving a module to a different location, is it still the same module in the new location?&lt;/li&gt;
  &lt;li&gt;when rename in function, does it acquire a new identity?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As in Hobbes’ riddle, multiple answers may be given to these questions, and which answer is the best is highly contextual. We therefore take the view that it is not up to the tooling (editors, programming languages) to decide on the answer, but rather that the tooling should be flexible enough so that the user may pick the most appropriate definition of historical identity.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/ship-of-theseus/&quot;&gt;Ship of Theseus&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on July 12, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Lehman's SPE-classfication]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/lehman-spe-classification/" />
  <id>http://expressionsofchange.com/lehman-spe-classification</id>
  <published>2017-07-04T00:00:00+02:00</published>
  <updated>2017-07-04T00:00:00+02:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;S-type programs&lt;/strong&gt; — programs whose function is formally defined by and derivable from a &lt;em&gt;specification&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;P-type programs&lt;/strong&gt; — programs for which the &lt;em&gt;problem&lt;/em&gt; may be precisely formulated, but for which the solution must inevitably reflect an approximation of the real world.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;E-type programs&lt;/strong&gt; — programs that mechanize a human or societal activity and are &lt;em&gt;embedded&lt;/em&gt; in the real world.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;P-type and E-type programs differ from S-type programs in that they represent a computer &lt;em&gt;application&lt;/em&gt; in the real world. They are together called A-type programs.&lt;/p&gt;

&lt;p&gt;It is A-type programs that are most prone to change.&lt;/p&gt;

&lt;p&gt;A longer summary of Lehman’s SPE-classification is given below, quoting heavily from the &lt;a href=&quot;https://cs.uwaterloo.ca/~a78khan/cs446/additional-material/scribe/27-refactoring/Lehman-LawsOfSoftwareEvolution.pdf&quot;&gt;original article&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;s-type-programs&quot;&gt;S-type programs&lt;/h3&gt;

&lt;p&gt;S-programs are programs whose function is formally defined by and derivable from a specification (hence the &lt;em&gt;S&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Examples are the lowest common multiple of two integers, eight queens and dining philosophers.&lt;/p&gt;

&lt;p&gt;Such problems may relate directly and primarily to the external world, but be completely defined.&lt;/p&gt;

&lt;p&gt;Correct solution of the problem as stated, in terms of the programming language being used, becomes the programmer’s sole concern. At most, questions of elegance or efficiency may also creep in.&lt;/p&gt;

&lt;p&gt;When this view can be legitimately taken the resultant program is conceptually static. One may change it to improve its clarity or its elegance, to decrease resource usage when the program is executed, even to increase confidence in its correctness.  But any such changes must not effect the mapping between input and output that it achieves in execution.&lt;/p&gt;

&lt;p&gt;In S-programs, judgments about the correctness, and therefore the value, of the programs relate by definition only to its specification.&lt;/p&gt;

&lt;h3 id=&quot;p-type-programs&quot;&gt;P-type programs&lt;/h3&gt;

&lt;p&gt;P-programs are programs for which the problem may be precisely formulated, but for which the solution must inevitably reflect an approximation of the real world. (&lt;em&gt;P&lt;/em&gt; for real world &lt;em&gt;problem&lt;/em&gt; solution).&lt;/p&gt;

&lt;p&gt;As an example, consider a program to play chess. The rules of the game of chess are completely specified; a procedure to make the best move at any given position can also be completely specified formally. Such a procedure is for example to, at any given position, create the tree of all games that may develop from it and adopt a minimax evaluation strategy to select the next move.&lt;/p&gt;

&lt;p&gt;Because this search tree is very large, such an approach is not feasible in practice. Practical approaches to chess programs must therefore make some approximations.&lt;/p&gt;

&lt;p&gt;The process of creating P-programs happens in the context of an intrinsic feedback loop.&lt;/p&gt;

&lt;p&gt;Despite the fact that the problem to be solved can be precisely defined, the acceptability of a solution is determined by the environment in which it is embedded.&lt;/p&gt;

&lt;p&gt;The solution obtained will be evaluated by comparison with the real environment.&lt;/p&gt;

&lt;p&gt;In P-programs, the concern is not centered on the problem statement but on the value and validity of the solution obtained in its real-world context.&lt;/p&gt;

&lt;h3 id=&quot;e-type-programs&quot;&gt;E-type programs&lt;/h3&gt;

&lt;p&gt;E-programs are those programs that mechanize a human or societal activity. The program has become a part of the world it models, it is embedded in it (hence the &lt;em&gt;E&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;They are are inherently even more change prone than P-programs in the following ways:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;It is not necessarily possible to precisely formulate the problem in the first place; the formulation of the specification must involve opinion and judgement. Once the program starts to be used, it creates feedback about this problem formulation, which leads to pressure for change.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The program affects the world it is embedded in: the usage patterns, habits, capabilities and expectations of its users and others. By so affecting the world, further pressure for change is created.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The world that’s being modeled may itself change, independently from the program. To stay relevant in the changing world, the program must change.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Examples of such programs are plentiful: Operating Systems, business administration software, inventory management, stock trading etc.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/lehman-spe-classification/&quot;&gt;Lehman's SPE-classfication&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on July 04, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Hash Consing]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/hash-consing/" />
  <id>http://expressionsofchange.com/hash-consing</id>
  <published>2017-07-04T00:00:00+02:00</published>
  <updated>2017-07-04T00:00:00+02:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;p&gt;When introducing the editor we introduced &lt;a href=&quot;/introducing-the-editor/#a-clef-for-construction&quot;&gt;a set of operations that represent changes&lt;/a&gt; (we called this a &lt;em&gt;clef&lt;/em&gt;). Two of the operations presented so far take a full history as one of their parameters:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert index history&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Replace index history&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We might wonder how to represent a serialization of such an operation, with the purpose of storing it in memory on disk or sending it over a network. Such a serialization must include a serialization of the parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;history&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this article we’ll show how this is presently implemented in the editor.&lt;/p&gt;

&lt;h3 id=&quot;the-problem-history-size&quot;&gt;The problem: history-size&lt;/h3&gt;

&lt;p&gt;In a naive implementation we might serialize the full history and include it into the serialization of the &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; operation. The problem with this approach is that histories tend to grow over time (by definition).&lt;/p&gt;

&lt;p&gt;To see to which degree this would be an unworkable approach, consider the following. The &lt;em&gt;raison d’être&lt;/em&gt; of the &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; operation as defined above is to allow the histories of arbitrary hierarchical structures to be composed of the histories of their substructures.&lt;/p&gt;

&lt;p&gt;As an example of a practical application of that principle would be to keep track of the history of a single computer’s Operating System and applications. In the composed approach, such a system-level history is composed of the histories of each application, which are composed of the histories of their modules, functions, etc. down to the histories of the smallest expressions of which the applications are composed.&lt;/p&gt;

&lt;p&gt;The smallest change to such a system would be to make a single change to one such of the smallest such sub-expressions, and then to bubble up the change through recursive application of the &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; operation. This would then result in the following &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; operations:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The history of the system as a whole is extended with a &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; operation which takes as a parameter…&lt;/li&gt;
  &lt;li&gt;The history of some software application as it was previously, but extended with a &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; operation which takes as a parameter…&lt;/li&gt;
  &lt;li&gt;The history of some module as it was previously, but extended with a &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; operation which takes as a parameter…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;etc.&lt;/p&gt;

&lt;p&gt;If we model the serialization of such &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; operations naively, by including the full history as a parameter, the top-level &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; from the above example would need to contain the full history of some application, which in turn contains full histories of modules, etc etc. This leads to polynomial space-complexity in the length of the history (with the depth of the tree being the exponent).&lt;/p&gt;

&lt;p&gt;The challenge is therefore: being able to reference arbitrarily large histories at a constant cost.&lt;/p&gt;

&lt;h3 id=&quot;hashes-to-the-rescue&quot;&gt;Hashes to the rescue&lt;/h3&gt;

&lt;p&gt;The present prototype of the editor solves this problem as such:&lt;/p&gt;

&lt;p&gt;First, we recognise that the history is a list of changes; the oldest change being the first element, the newest change being the last element in the list.&lt;/p&gt;

&lt;p&gt;Any list of serializable elements may be modeled as a collection of records, where each record consists of 2 fields:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The element, as a serialized string of bytes.&lt;/li&gt;
  &lt;li&gt;Either [a] a hash of the previous record [b] a special value to denote no such record exists.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We can compute such a hash if the layout of the record is well-defined; the simplest such defintion (which is the one used in the editor) is to concatenate the serialized values of the 2 fields.&lt;/p&gt;

&lt;p&gt;If we keep a single hash table in which we can look up records given their hash, and this hash table contains (at least) all records from a given list, we can always reconstruct lists from a given the hash of the last element of the list.&lt;/p&gt;

&lt;p&gt;A similar technique in Lisp implementations is called &lt;a href=&quot;https://en.wikipedia.org/wiki/Hash_consing&quot;&gt;Hash Consing&lt;/a&gt;.&lt;sup id=&quot;fnref:terminology-notes&quot;&gt;&lt;a href=&quot;#fn:terminology-notes&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; More recent analogues are git’s commit object structure (though it implements a directed acyclic graph rather than a list because multiple ‘previous’ records may be referenced) and bitcoin’s blockchain.&lt;/p&gt;

&lt;p&gt;Recognizing that any list can be written in the Hash Consing style, and that histories are lists, we’ve implemented histories as such.&lt;/p&gt;

&lt;p&gt;It is precisely the hash of such a record that we can refer to from when serializing the operations &lt;code class=&quot;highlighter-rouge&quot;&gt;Insert&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt;, which takes constant space. This means that the space-complexity of our implementation of history is bounded by the product of the depth of the tree and the length of the history.&lt;/p&gt;

&lt;h3 id=&quot;considerations&quot;&gt;Considerations&lt;/h3&gt;

&lt;p&gt;Finally, we’ll look at some considerations.&lt;/p&gt;

&lt;p&gt;It is not strictly necessary to use a hash-based scheme to achieve the above-mentioned advantages in space-complexity. In principle, any scheme that deduplicates shared histories would suffice.&lt;/p&gt;

&lt;p&gt;For exampe, we might implement the histories as backlinked lists in-memory, and implement &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; to contain a pointer to the relevant item from the list.&lt;/p&gt;

&lt;p&gt;However, using a hash-based scheme brings several advantages over such an approach:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;There is no tie-in to the memory addressing scheme of a particular process; the in-memory format may thus be used as a serialization format for storage on disk or sharing over the network.&lt;/li&gt;
  &lt;li&gt;Deduplication of any shared history is automatic, there is no need to keep track of shared histories programatically.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:terminology-notes&quot;&gt;
      &lt;p&gt;It would be tempting but incorrect to use the term &lt;a href=&quot;https://en.wikipedia.org/wiki/Hash_list&quot;&gt;“hash list”&lt;/a&gt; to describe such a construct: that term is used to denote a structure where a list of hashses is used as an input to a single root hash. In other words: the individual elements of a hash list are not linking to each other, but are linked together at a single point. The term &lt;a href=&quot;https://en.wikipedia.org/wiki/Hash_chain&quot;&gt;“hash chain”&lt;/a&gt; seems to be reserved for repeated application a hash function to a single input. &lt;a href=&quot;#fnref:terminology-notes&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;

  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/hash-consing/&quot;&gt;Hash Consing&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on July 04, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[CLIs are reified UIs]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/reification-of-interaction/" />
  <id>http://expressionsofchange.com/reification-of-interaction</id>
  <published>2017-07-02T00:00:00+02:00</published>
  <updated>2017-07-02T00:00:00+02:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;p&gt;First, some definitions: Two main paradigms of interaction between humans and computers are Command Line Interfaces (CLIs) and Graphical User Interfaces (GUIs). In CLIs the user interacts with the computer by sequentially typing various textual commands, to which the computer replies, also in text. Graphical interfaces base the interaction with the computer on graphical icons and widgets and navigation typically depends on a pointing device such as the mouse. The debate on the respective advantages and disadvantages of these paradigms stretches back decades.&lt;/p&gt;

&lt;p&gt;Proponents of GUIs typically stress their ease of use, especially for non-experts. A key contributer to GUIs ease of use is &lt;em&gt;discoverability&lt;/em&gt;: at any time the various available options are laid out on the screen and can be further explored with the mouse.&lt;/p&gt;

&lt;p&gt;CLIs predate GUIs. Despite of the ease of use of the latter, usage of CLIs persists, especially in UNIX-like systems. This has come as a surprise to some. Typically offered explanations are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Power of the keyboard&lt;/strong&gt; — the keyboard allows for faster input than the alternation of keyboard &amp;amp; mouse usage.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Reproducability&lt;/strong&gt; - because all commands are text, they may be more easily reproduced and shared.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Composable commands&lt;/strong&gt; — commands on the command line may be arbitrarily composed, using the output of one command as the input of another. This allows for powerful means of expression.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Scripting&lt;/strong&gt; — the interactive session may be used as the basis for a script (a computer program), allowing for the automation of certain tasks.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Rather than rehashing old debates, I’ll try to present a somewhat new perspective on the matter. I’ll do so by examining the CLI through the lens of the present project,  &lt;em&gt;Expressions of Change&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;reification-of-interaction&quot;&gt;Reification of Interaction&lt;/h2&gt;

&lt;p&gt;Let’s start by stating the obvious: In a command-line interface the textual commands are displayed on screen as typed. The output of each command is displayed below it. Previously entered commands and outputs are scrolled up as required, i.e. when the screen is full.&lt;/p&gt;

&lt;p&gt;This means that the human-computer interaction is being expressed in a tangible and visible way. This can be said for both individual parts of the interaction (individual commands) and for the interaction as a whole (the history of an entire session).&lt;/p&gt;

&lt;p&gt;A more fancy way to say this is: the user-computer interaction is &lt;a href=&quot;https://en.wikipedia.org/wiki/Reification_(computer_science)&quot;&gt;reified&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Note how this contrasts with the typical interaction in a GUI: There, after clicking on some button or icon, the GUI will respond in some way, e.g. by opening a new screen or copying a file. However, the action of clicking the button itself can no longer be observed, manipulated or shared after it has happened.&lt;sup id=&quot;fnref:gui-reification&quot;&gt;&lt;a href=&quot;#fn:gui-reification&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;In CLIs, as mentioned above, the commands as given and their outputs are displayed on screen. In typical setups the support for reification is a bit more powerful than that:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Keyboard shortcuts&lt;/strong&gt; — several keyboard shortcuts allow for usage of past commands, e.g. arrow-up typically shows the previously issued command, and CTRL+R typically opens a search prompt which allows for searching previously issued commands. Previous commands are not just visible on screen, but can be selected with minimal effort.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Copy/paste&lt;/strong&gt; — support for copy/paste makes it so that arbitrary text from the screen may be copied, and that text from arbitrary sources (including the screen itself) may be pasted as a new command. Note the symmetry between the input and output formats: everything is text. This allows for the copying of an entire session’s output into the documentation, an internet forum or script. Conversely, solutions from internet forums may be copied into the session without friction.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Persistent history&lt;/strong&gt; — the full history of commands is written to a file, which can include the date and time they were issued.&lt;sup id=&quot;fnref:config-notes&quot;&gt;&lt;a href=&quot;#fn:config-notes&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; This allows for the answering of questions such as:&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;“How did I use this command last time I used it?”&lt;/li&gt;
      &lt;li&gt;“Which packages have been installed on this system?”&lt;/li&gt;
      &lt;li&gt;“I thought I already solved this yesterday, am I losing my mind?”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The relationship with the project that this site is about, &lt;em&gt;Expressions of Change&lt;/em&gt;, is quite simple. The commands, or at least some of them, affect the system, and are thus the changes. The fact that they are reified is simply another way of saying that commands are available as a first level citizens. We can see them, copy them, and even generate them using other commands. In other words: reification of interaction as in CLIs is an actually existing and quite popular example of an expression of change!&lt;/p&gt;

&lt;p&gt;As an aside: A number of the often cited advantages of CLIs might be interpreted simply as natural consequences of the reification: looking at the list of advantages from the introduction of the article, we see that both reproducability across sessions and the ability to take an interactive session as the basis for a script are simply direct consequences of the reification.&lt;/p&gt;

&lt;h3 id=&quot;guis&quot;&gt;GUIs&lt;/h3&gt;

&lt;p&gt;The above is not to be taken as an argument that CLIs are a fundamentally better paradigm of user-computer interaction than GUIs. The point is rather that reification of interaction is extremely valuable, and that it is worthwhile to consider how to include it in &lt;em&gt;any&lt;/em&gt; interface, even a GUI.&lt;/p&gt;

&lt;p&gt;There is, after all, no &lt;em&gt;fundamental&lt;/em&gt; reason a GUI could not be designed with the goal of reification of interaction in mind; it’s just that it is rarely done in practice.&lt;/p&gt;

&lt;p&gt;The main way in which reification of interaction shows up in GUIs is through the undo command. Unfortunately this is often implemented in ways that are &lt;a href=&quot;/the-power-of-undo/&quot;&gt;much less generally applicable&lt;/a&gt; than those we’ve seen of CLIs.&lt;/p&gt;

&lt;h2 id=&quot;limits-to-the-reification&quot;&gt;Limits to the reification&lt;/h2&gt;

&lt;p&gt;Having established that CLIs reify the user-computer interaction to some degree, it is interesting to consider some typically applying practical limitations.&lt;/p&gt;

&lt;p&gt;As mentioned above, the commands as given by the user are stored in a sequential history. One standard for history-keeping is the following: If we start with a clean system, and replay all the commands from the history, will we end up with the same system? This is a way of measuring how much of the relationship between the past and the present is actually captured by the history.&lt;/p&gt;

&lt;p&gt;For CLIs in the UNIX-like world, the answer to the question is “we will typically not end up with the same system”. There are a number of reasons for this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The history is not properly organized. The commands may interact with one another via their “environment”, but the relevant information to reproduce the interactions is not stored. For example, the &lt;code class=&quot;highlighter-rouge&quot;&gt;cd&lt;/code&gt; command may change the working directory; consecutive commands should then be interpreted as being executed from that directory. However, the history does not reflect the closing of sessions or the creation of new ones, so we cannot say about a command from which directory it was executed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The history is incomplete. Your interaction with the system as a whole is not restricted to the interaction via the CLI but will typically include interaction with arbitray applicationsand the meaning of the commands themselves is not constricted in any way. We cannot make &lt;em&gt;any&lt;/em&gt; statement about how these arbitrary commands and applications affect the system with certainty.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Out of these limitations other follow. For example: the undo-command is not available in CLIs, because it would imply some constraint on the available commands (namely: commands should be limited to those that can be undone).&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;A unique advantage that Command Line Interfaces typically offer over Graphical User Interfaces is that the interaction between user and computer is reified: it is made visible, and the user can directly interact with it, for example by copy/pasting commands.&lt;/p&gt;

&lt;p&gt;Many of the typically cited advantages of the command line are simply a consequence of this important fact.&lt;/p&gt;

&lt;p&gt;The reification of interaction is, however, not fundamentally limited to CLIs, and the concept may just as well be applied to GUIs.&lt;/p&gt;

&lt;p&gt;We have also seen a number of typical limitations to the reification of interaction as typically available in the CLIs of UNIX-like systems; such limitations are not fundamental to the reification, but are a consequence of the reification being accidental rather than being an explicit design goal in the design of the UNIX.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:gui-reification&quot;&gt;
      &lt;p&gt;Tools to record interactions with GUIs do exist, but they are significantly less useful and robust than their (built-in) counterpart in CLIs. &lt;a href=&quot;#fnref:gui-reification&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:config-notes&quot;&gt;
      &lt;p&gt;Making sure the saved history has (virtually — from the human perspective) unlimited length and saving the timestamps typically requires some configuration. &lt;a href=&quot;#fnref:config-notes&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;

  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/reification-of-interaction/&quot;&gt;CLIs are reified UIs&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on July 02, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Dijkstra's Mozart]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/dijkstras-mozart/" />
  <id>http://expressionsofchange.com/dijkstras-mozart</id>
  <published>2017-07-02T00:00:00+02:00</published>
  <updated>2017-07-02T00:00:00+02:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;p&gt;The full quote, transcribed here from the subtitles, is as such:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There are very different programming styles. I tend to see them as Mozart versus Beethoven. When Mozart started to write, the composition was finished. He wrote the manuscript in one go. In beautiful handwriting too. Beethoven was a doubter and a struggler who started writing before he finished the composition. And then glued corrections onto the page. In one place he did this nine times. When they peeled them, the last version proved identical to the first one.&lt;/p&gt;

  &lt;p&gt;That iterative method of programming is somehow a very Anglo-Saxon custom. British education is pervaded by it. People learn, when they write, not to try to get it right the first time. Just write what’s on your mind and then rewrite repeatedly to get the product you want. That’s partly why word processors are marketed so aggressively and partly why they have been so successful here. While it is one of the advantages of working with pen and paper that when you start a sentence you should have it ready.&lt;/p&gt;

  &lt;p&gt;— Edsger W. Dijkstra&lt;sup id=&quot;fnref:noorderlicht&quot;&gt;&lt;a href=&quot;#fn:noorderlicht&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Although it is not mentioned explicitly in the above, there can be little doubt that Dijkstra considers the Mozart style to be superior – especially if you consider that Anglo-Saxon is a pejorative in Dijkstra’s vocabulary.&lt;/p&gt;

&lt;p&gt;Admittedly, the metaphor is an inspiring one: the image of a wise man pondering a problem on long walks, writing down the whole thing only when all is clear in a single sitting (preferably with a fountain pen) is certainly romantic.&lt;/p&gt;

&lt;p&gt;The image may especially rouse feelings of nostalgia when contrasted with the daily reality of trying to stay afloat in an ever increasing see of garbage. In a time where getting software out the door as quickly as possible is the all-overriding concern Dijkstra’s focus on elegance comes as a breath of fresh air.&lt;/p&gt;

&lt;p&gt;However, like most romantic images, the metaphor does not survive a closer examination.&lt;/p&gt;

&lt;h2 id=&quot;the-mythological-mozart&quot;&gt;The Mythological Mozart&lt;/h2&gt;

&lt;p&gt;The first problem with the Mozart style of programming is that the image that Dijkstra presents of Mozart is itself largely a mythological construction.&lt;/p&gt;

&lt;p&gt;The myth that Mozart composed his music fully in his head before committing anything to paper has its roots in a large part in a letter of which a key passage is presented below. It was published in 1815, more than two decades after his death, and addresses a certain “Baron von —”:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When I am, as it were, completely myself, entirely alone, and of good cheer; say travelling in a carriage, or walking after a good meal, or during the night, when I cannot sleep; it is on such occasions that my ideas flow best and most abundantly. [..] Those ideas that please me, I retain in memory [..] and provided I am not disturbed, my subject enlarges itself, becomes methodized and defined, and the whole, though it be long, stands almost finished and complete in my mind, so that I can survey it, like a fine picture or a beautiful statue, at a glance. Nor do I hear in my imagination the parts successively, but I hear them, as it were, all at once. [..] What has been thus produced I do not easily forget [..]&lt;/p&gt;

  &lt;p&gt;When I proceed to write down my ideas, I take out of the bag of my memory, if I may use that phrase, what has previously been collected into it, in the way I have mentioned. For this reason, the committing to paper is done quickly enough, for every thing is, as I said before, already finished; and it rarely differs on paper, from what it was in my imagination. At this occupation I can therefore suffer myself to be disturbed; for whatever may be going on around me, still I write.&lt;/p&gt;

  &lt;p&gt;— not Mozart&lt;sup id=&quot;fnref:baron-von-x&quot;&gt;&lt;a href=&quot;#fn:baron-von-x&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This letter was already exposed as a forgery in the 1860s&lt;sup id=&quot;fnref:otto-jahn&quot;&gt;&lt;a href=&quot;#fn:otto-jahn&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;, but this did not stop the myth from being perpetuated.&lt;/p&gt;

&lt;p&gt;Contrasting with the forgery are multiple surviving letters that are known to be authentic. First, letters sent by Mozart’s mother on their joint arrival in Paris describe first how bored he is without a keyboard in the room. A second letter describes hat, when it turns out that the stairs are too narrow to carry a keyboard to the room, that Mozart will need to do his composing away from home. A third, sent Three years later by Mozart himself upon moving to Vienna, describes how renting a keyboard is his first priority, so that he may turn to composing as soon as possible.&lt;sup id=&quot;fnref:authentic-letters&quot;&gt;&lt;a href=&quot;#fn:authentic-letters&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;The decision, made after his death by his widow Constanze, to throw away all drafts of completed works, and keep only sketches and drafts of uncompleted ones helped to establish the &lt;sup id=&quot;fnref:constanze&quot;&gt;&lt;a href=&quot;#fn:constanze&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt; myth that Mozart wrote down his compositions in a single writing. Fortunately, plenty of sketches  remain to show to us that Mozart used sketches extensively in his creative process (albeit perhaps not as extensively as Beethoven) throughout his career; one of such sketches is shown at the bottom of the image below.&lt;/p&gt;

&lt;p&gt;The research into the myth versus reality of the Mozart’s compositional method is extensive enough to have its own &lt;a href=&quot;https://en.wikipedia.org/wiki/Mozart&#39;s_compositional_method&quot;&gt;Wikipedia page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/mozart-jottings.jpg&quot; alt=&quot;An example of surviving &amp;quot;work in progress&amp;quot; by Mozart&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;bigger-problems&quot;&gt;Bigger problems&lt;/h2&gt;

&lt;p&gt;Let’s step away from the specifics of Mozart for a moment, and consider the merits of the Mozart programming style independently of the truth of chosen example.&lt;/p&gt;

&lt;p&gt;A simple observation is that even the greatest genius has a limited mental capacity. Assuming an equivalent of the mythological Mozart exists in the realm of programming, at some point this mental capacity runs out. Applied to programming: you may be able to understand a single small or medium-sized program fully at once; but at some point, the program as a whole becomes too large to fit in a single person’s head in full.&lt;/p&gt;

&lt;p&gt;With the risk of of starting a flame war, we might also wonder which art has the greater capacity for complexity: that of composing music or programs? Firstly, we might observe that the length of programs has almost no theoretical upper bound, whereas a musical composition’s length is bounded by the endurance of the human bladder. Secondly, let’s see what Dijkstra himself has to say about the subject:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Programming is one of the most difficult branches of applied mathematics; the poorer mathematicians had better remain pure mathematicians.&lt;/p&gt;

  &lt;p&gt;— Edsger W. Dijkstra, &lt;a href=&quot;https://www.cs.utexas.edu/users/EWD/ewd04xx/EWD498.PDF&quot;&gt;EWD498&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In short: If you can solve a problem entirely in your head, perhaps you should be working on bigger problems.&lt;/p&gt;

&lt;h2 id=&quot;changing-circumstances&quot;&gt;Changing circumstances&lt;/h2&gt;

&lt;p&gt;There is one more critical difference with with music: whereas a piece of music may at some point be finished, many programs are, by design, never finished.&lt;/p&gt;

&lt;p&gt;This is at least true for the class of software that is often labeled “business software”: Software that models the processes of a real-world organization to be able to facilitate its real-world processes. Examples are programs to calculate insurances premiums, facilitate logistics and collect taxes; some of such programs are implemented specifically for any given organization, others serve an entire market. All such software must be changed whenever the real world it is modelling changes, and is only finished when the organization it’s supporting dies.&lt;/p&gt;

&lt;p&gt;The ever changing nature of programs is also caused by the fact that the existence of the software may create further wishes to change it. Just like Mozart couldn’t compose without a piano and many programmers cannot program without a keyboard, many organizations cannot compose their requirements without the feedback of an actually working program. That learning about the requirements of a given program can only be meaningfully done with an actual running version of the program is one of the central tenets of the &lt;em&gt;Agile&lt;/em&gt; movement.&lt;/p&gt;

&lt;p&gt;Applying the model of the mythological Mozart to ever changing requirements asks of us to believe in a programmer that cannot only see the current version of a program in their head in its entirety, but also possesses the skill of foreseeing the future - quite a feat indeed!&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;Aspiring to elegance in programming is laudable; given the state of our field it can’t really hurt to raise the bar a bit by listening to Dijkstra’s words.&lt;/p&gt;

&lt;p&gt;Let’s not base this aspiration on a mythical vision of Mozart and the human creative process though. The creative process is messy; requiring experimentation, drafts and interaction with our instruments. Let’s look out for tools that facilitate this, rather than base our hopes on a small group of geniuses.&lt;/p&gt;

&lt;p&gt;Let’s also realize that software does not operate in a static environment: writing the best version 1.0 we can, knowing full well that there will be a version 2.0.&lt;/p&gt;

&lt;p&gt;Beethoven is still widely considered one of the world’s best composers by any measure. Perhaps his methods weren’t so crazy after after all.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:noorderlicht&quot;&gt;
      &lt;p&gt;The video is available at the &lt;a href=&quot;http://www.cs.utexas.edu/users/EWD/video-audio/NoorderlichtVideo.html&quot;&gt;Edsger W. Dijkstra Archive&lt;/a&gt; and on &lt;a href=&quot;https://youtu.be/RCCigccBzIU?t=4m20s&quot;&gt;YouTube&lt;/a&gt;; the relevant quote starts at 4:20. &lt;a href=&quot;#fnref:noorderlicht&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:baron-von-x&quot;&gt;
      &lt;p&gt;The letter was published in German 1815 in the &lt;a href=&quot;https://books.google.nl/books?id=MxNDAAAAcAAJ&amp;amp;pg=PA561#v=onepage&amp;amp;q&amp;amp;f=true&quot;&gt;Allgemeine Musikalische Zeitung&lt;/a&gt;, the English translation above is from the &lt;a href=&quot;https://books.google.nl/books?id=9jFDAAAAcAAJ&amp;amp;dq=harmonicon&amp;amp;pg=PA198#v=onepage&amp;amp;q&amp;amp;f=false&quot;&gt;1825 Harmonicon&lt;/a&gt; &lt;a href=&quot;#fnref:baron-von-x&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:otto-jahn&quot;&gt;
      &lt;p&gt;The fact that the letter is a forgery was first pointed out by Otto Jahn, in his biography “Life of Mozart”. &lt;a href=&quot;#fnref:otto-jahn&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:authentic-letters&quot;&gt;
      &lt;p&gt;From the &lt;a href=&quot;http://rmc.library.cornell.edu/mozart/myth/TellTale_Letters.htm&quot;&gt;Cornell University Library’s Division of Rare and Manuscript Collections - Tell-Tale Letters&lt;/a&gt; &lt;a href=&quot;#fnref:authentic-letters&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:constanze&quot;&gt;
      &lt;p&gt;From the &lt;a href=&quot;http://rmc.library.cornell.edu/mozart/compose.htm&quot;&gt;Cornell University Library’s Division of Rare and Manuscript Collections - How did Mozart Compose?&lt;/a&gt; &lt;a href=&quot;#fnref:constanze&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;

  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/dijkstras-mozart/&quot;&gt;Dijkstra's Mozart&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on July 02, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[The Editor - First Video]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/the-editor-a-video/" />
  <id>http://expressionsofchange.com/the-editor-a-video</id>
  <published>2017-07-01T00:00:00+02:00</published>
  <updated>2017-07-01T00:00:00+02:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;iframe width=&quot;680&quot; height=&quot;382&quot; src=&quot;https://www.youtube.com/embed/c9DmkBHLs3M&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/the-editor-a-video/&quot;&gt;The Editor - First Video&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on July 01, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Introducing the Editor]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/introducing-the-editor/" />
  <id>http://expressionsofchange.com/introducing-the-editor</id>
  <published>2017-06-29T00:00:00+02:00</published>
  <updated>2017-06-29T00:00:00+02:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;p&gt;The proposed alternative is to make &lt;em&gt;changes to programs&lt;/em&gt; the primitive building blocks, instead of the &lt;em&gt;programs that result from such changes&lt;/em&gt;. In this view, the means of construction are seen as equally important as the constructed artifacts. The idea is simply that, to be able meaningfully to reason about change, it is easier to keep the actual change at hand than to guess what it might have been.&lt;/p&gt;

&lt;p&gt;The decision to abandon text files as a possible input format has an important consequence for the roadmap of this project: editors that create text files are plentiful, but the type of editor that could be used to create changes as a primitive has yet to be designed. The first step in the project is therefore to design and implement such an editor.&lt;/p&gt;

&lt;p&gt;This will allow us to get some feedback on what works and what doesn’t, and on what the major challenges for such an editor are.&lt;/p&gt;

&lt;p&gt;Also, importantly, it will allow us to actually create the inputs for the yet to be designed programming language.&lt;/p&gt;

&lt;p&gt;In the below, we will sketch some important properties of such an editor.&lt;/p&gt;

&lt;h3 id=&quot;means-of-combination&quot;&gt;Means of combination&lt;/h3&gt;

&lt;p&gt;The first goal for our editor was mentioned already: the changes to programs shall be primitive entities in our editor. The second goal is that it shall be possible to combine these primitives in meaningful ways.&lt;sup id=&quot;fnref:sicp&quot;&gt;&lt;a href=&quot;#fn:sicp&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;The most straightforward such combination is to take of a linear sequence of such changes; we’ll call this a “history”.&lt;/p&gt;

&lt;p&gt;A more subtle means of combination arises when editing hierarchically structured documents, such as computer programs. Hierarchical documents, by definition, compose larger parts out of smaller parts. This leads to the question: how do the histories of the parts relate to their sub-parts?&lt;/p&gt;

&lt;p&gt;For the editor presented below, the answer is: the histories between relate in a meaningful way. In particular, the history of some part of our program will be composed of the histories of its subparts.&lt;/p&gt;

&lt;h3 id=&quot;structured-editing&quot;&gt;Structured editing&lt;/h3&gt;

&lt;p&gt;In the above we’ve established three things: first that we need to create an editor for computer programs, second that changes shall be its primitives and third that histories of changes shall be meaningfully composable along the lines of the document’s structure.&lt;/p&gt;

&lt;p&gt;These goals point strongly in the direction of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Structure_editor&quot;&gt;structured editor&lt;/a&gt;, meaning an editor that is aware of the document’s structure. There are two main reasons for this:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;To establish a good inventory of primitive operation of change: If we would treat the structure of the edited document as a black box, we could not say anything meaningful about changes to it. We must thus take the opposite approach and acknowledge the document’s structure.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;To be able to compose and decompose histories along structural lines — that we need to acknowledge the document’s structure to be able to do this should be obvious.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Incidentally, structured editing brings with it many other advantages: certain classes of incorrect programs cannot be constructed, there is no need to write a parser, meaningful reporting on errors is much easier etc. etc. We shall gladly make use of such advantages, but they are not the initial cause for the decision.&lt;/p&gt;

&lt;p&gt;Finally, note that the decision to create a structured editor rather than an unstructured one incurs no extra cost on our implementation. Because a radical departure from the main paradigms of text editing is the starting point of our design, we are free to drop any defaults from that paradigm, such as the fact that everything is unstructured text.&lt;/p&gt;

&lt;h3 id=&quot;structure-s-expressions&quot;&gt;Structure: S-Expressions&lt;/h3&gt;

&lt;p&gt;So far we have established that the editor to be is to be a structured editor and that its primitives will be the changes to some structure. Now then, before we can turn our attention to those primitives, we must first decide what that structure looks like.&lt;/p&gt;

&lt;p&gt;For the first prototype, I have decided on the simplest thing that could possibly work: &lt;a href=&quot;https://en.wikipedia.org/wiki/S-expression&quot;&gt;s-expressions&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;S-Expressions are&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;an atom (some symbol or value), or&lt;/li&gt;
  &lt;li&gt;a list of 0 or more s-expressions&lt;sup id=&quot;fnref:lists-not-tuples&quot;&gt;&lt;a href=&quot;#fn:lists-not-tuples&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With these two types of elements we can build tree like structures with at the leaves either empty lists or atoms.&lt;/p&gt;

&lt;p&gt;The primary motivation for picking such a minimal syntax is a practical one: the scope of the project is rather large as it stands and a programming language family which is expressed in S-Expressions is readily available (&lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot;&gt;Lisp&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;From a usability perspective, S-Expressions are also desirable. There are only two kinds of S-Expression (atoms &amp;amp; lists) and the mapping between S-Expressions and their visual representation is very straightforward. Since the structure of the program is readily visible, the programmer needs not create a separate mental model of it in their head; this makes structured editing feasible.&lt;/p&gt;

&lt;p&gt;Most advances in programming language research in the last few decades, most notably in type systems, have been made in &lt;a href=&quot;https://en.wikipedia.org/wiki/ML_(programming_language)&quot;&gt;ML&lt;/a&gt; and its derivatives. To be able to incorporate those while retaining elegance an upgrade to a less minimal syntax may be required at some point. However, for the first version of the editor a minimal syntax is sufficient — the focus on change as a primitive will yield sufficient insights to make the experiment worthwhile.&lt;/p&gt;

&lt;h3 id=&quot;a-clef-for-construction&quot;&gt;A Clef for Construction&lt;/h3&gt;

&lt;p&gt;Having established what the structure of our documents will be, we can turn our attention to the primitives of construction. In other words, we’ll have to decide on a set of operations to construct and modify S-Expressions. We’ll call such a set of primitives a &lt;em&gt;Clef&lt;/em&gt;&lt;sup id=&quot;fnref:why-clef&quot;&gt;&lt;a href=&quot;#fn:why-clef&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;This is just as much a design decision as picking the syntax of the language in the first place. Here too, the space from which we can choose is infinite.&lt;sup id=&quot;fnref:infinite-space&quot;&gt;&lt;a href=&quot;#fn:infinite-space&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt; The forces working on this decision are similar too; they are roughly:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Adding more elements to the &lt;em&gt;clef&lt;/em&gt; potentially allows for more precise descriptions of history and expressions of intent (good).&lt;/li&gt;
  &lt;li&gt;Adding more elements imposes an implementation cost (bad).&lt;/li&gt;
  &lt;li&gt;Adding more elements imposes a mental burden on the programmer (bad).&lt;/li&gt;
  &lt;li&gt;Adding more elements increases the risk that multiple equivalent mechanisms exist to construct the same result, even in cases when there is no meaningful underlying reason for this (bad).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the below I will present a particular clef as decided upon (for now); leaving the description of the thought-process of the decision itself to another (yet to be written) article.&lt;/p&gt;

&lt;p&gt;The clef defines the following operations:&lt;sup id=&quot;fnref:imperative-functional-equivalence&quot;&gt;&lt;a href=&quot;#fn:imperative-functional-equivalence&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeAtom atom&lt;/code&gt; — Out of nothingness, spawn a given atom; or replace an existing atom with the given atom.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt; - Out of nothingness, spawn an empty list.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert index history&lt;/code&gt; For a list, insert at the index the s-expr that can be constructed from the history; shifting items to the right as required.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Delete index&lt;/code&gt; — For a list, delete the element at the index; shifting items to the left as required.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Replace index history&lt;/code&gt; — For a list, replace the element at the index with the s-expr that can be constructed from the history.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using this clef we can both construct any s-expressions from scratch and modify any given s-expression into any other (a formal proof is left as an exercise to the reader). As an example, consider a possible way to construct the s-expression &lt;code class=&quot;highlighter-rouge&quot;&gt;(+ (* 6 9) 12)&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt; — starting with an empty list expression&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 (BecomeAtom +))&lt;/code&gt; — as the first item, insert the history which consists of the creation of the atom &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 1 ...&lt;/code&gt; — as the second item, insert the result of the following history:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt; — starting with an empty list (sub)expression&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 (BecomeAtom *))&lt;/code&gt; — introducing the atoms one…&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 1 (BecomeAtom 6))&lt;/code&gt; — by one…&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 2 (BecomeAtom 9))&lt;/code&gt; — by one.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 2 (BecomeAtom 12))&lt;/code&gt; — similar to the construction of &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The above example is quite trivial, because the order of construction is precisely identical to the ordering of the result. In practice the order might be quite different, and might also include deletions (and therefore: insertions whose effects are not visible in the final result).&lt;/p&gt;

&lt;p&gt;Another history leading to the same result is shown below. Note that the indices are not the same as in the first example, but the result is the same.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 (BecomeAtom 12))&lt;/code&gt; — we start with a single element &lt;code class=&quot;highlighter-rouge&quot;&gt;12&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 (BecomeAtom +))&lt;/code&gt; — to the left of it, we introduce the &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 1 ...&lt;/code&gt; — assuming the same history on the ellipses as in the first example&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Importantly, the clef also allows us to express the histories of larger parts of our document as being composed of the histories of their subparts.&lt;/p&gt;

&lt;p&gt;To see how this is so, consider the following: The s-expressions form a tree. If the history of a given node is extended by some change, we can apply &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; on its parent node, providing the node’s index in the parent and the extended history. Because this &lt;code class=&quot;highlighter-rouge&quot;&gt;Replace&lt;/code&gt; represents a change at the level of the parent, we can repeat this process until we reach the root of the tree. Using this mechanism, the same example might look like this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 (BecomeAtom +))&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 1 ...&lt;/code&gt; — We start by adding an empty sub-expression…
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Replace 1 ...&lt;/code&gt; — which is then extended with &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 (BecomeAtom *))&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Replace 1 ...&lt;/code&gt; — and extended with &lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 (BecomeAtom *))&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 1 (BecomeAtom 6))&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 2 (BecomeAtom 12))&lt;/code&gt; — intermezzo on the top-level&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Replace 1 ...&lt;/code&gt; — and extended with &lt;code class=&quot;highlighter-rouge&quot;&gt;9&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BecomeList&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 0 (BecomeAtom *))&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 1 (BecomeAtom 6))&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert 2 (BecomeAtom 9))&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This example makes a number of things clear: first that we can see the full ordering of events from the top level, and that work on sub-expressions may be arbitrarily interleaved. In the example above this is demonstrated by the insertion of the atom &lt;code class=&quot;highlighter-rouge&quot;&gt;12&lt;/code&gt; before the completion of the sub-expression &lt;code class=&quot;highlighter-rouge&quot;&gt;(* 6 9)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Second, that from each sub-level we see the ordering of events relevant to that sub-level. In this case, the precise ordering of the creation of the atoms &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;9&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Third, it shines some light on some challenges. Namely, the example as given is horribly verbose, which makes it hard to read for humans and has implications on the performance characteristics of the implementation. For both these problems solutions have already been found, which will be presented in the next parts.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;This concludes the most basic introduction to the editor.&lt;/p&gt;

&lt;p&gt;We’ve seen the goal: having change available as a primitive, and being able to meaningfully express compositions over change. We’ve seen that it is a structured editor and why this should be so.&lt;/p&gt;

&lt;p&gt;We’ve also encountered the first design decisions: the decision for s-expressions as a basic syntax, and a particular choice for a &lt;em&gt;clef&lt;/em&gt; and how this is sufficient for the stated goals.&lt;/p&gt;

&lt;p&gt;In the upcoming &lt;a href=&quot;/the-editor-a-video/&quot;&gt;parts we’ll show the current prototype in action&lt;/a&gt;, and will discuss some of the open questions and implementation details.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:sicp&quot;&gt;
      &lt;p&gt;Asking the three questions “What are your primitives, what are your means of combination and what are your means of abstraction?” is directly inspired by Abelson &amp;amp; Sussman’s excellent lectures and book on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs&quot;&gt;Structure and Interpretation of Computer Programs&lt;/a&gt;. &lt;a href=&quot;#fnref:sicp&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:lists-not-tuples&quot;&gt;
      &lt;p&gt;The canonical definition of S-Expressions treats lists as mere syntactic sugar for nested pairs; i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;(x y z)&lt;/code&gt; is simply a shorthand for &lt;code class=&quot;highlighter-rouge&quot;&gt;(x . (y . (z . NIL)))&lt;/code&gt;. In this implementation the opposite approach is taken as to allow for primitives of change on such lists that are sufficiently expressive. &lt;a href=&quot;#fnref:lists-not-tuples&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:why-clef&quot;&gt;
      &lt;p&gt;The name &lt;em&gt;Clef&lt;/em&gt; refers to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Clef&quot;&gt;musical clef&lt;/a&gt;; musical notation serves as a metaphore for &lt;em&gt;expressions of change&lt;/em&gt; because it’s a nice real world example of a sequential list of instructions for “construction”. In this metaphore, the &lt;em&gt;Clef&lt;/em&gt; defines which notes are playable, i.e. what our vocabulary of change is. &lt;a href=&quot;#fnref:why-clef&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:infinite-space&quot;&gt;
      &lt;p&gt;To see that there are literally infinitely many possible primitive operations of change, consider the following: there are infinitely many s-expressions, and we can always define a special operation of change for any given s-expression. &lt;a href=&quot;#fnref:infinite-space&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:imperative-functional-equivalence&quot;&gt;
      &lt;p&gt;The definitions are formulated in the imperative style (e.g. “delete at i”); an equivalent functional definition can be trivially constructed (“given a list, return an list without element i”). &lt;a href=&quot;#fnref:imperative-functional-equivalence&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;

  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/introducing-the-editor/&quot;&gt;Introducing the Editor&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on June 29, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Existing tools]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/existing-tools/" />
  <id>http://expressionsofchange.com/existing-tools</id>
  <published>2017-06-27T00:00:00+02:00</published>
  <updated>2017-06-27T00:00:00+02:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;p&gt;Arguably, the existence of so many tools is a strong indication that the underlying problem, that of dealing with change in software development, is one which requires tooling to be properly handled.&lt;/p&gt;

&lt;p&gt;The next questions is then: is it also an indication that this is a solved problem? Given that this site documents attempts to come up with better &lt;em&gt;Expressions of Change&lt;/em&gt;, it will not come as a surprise that my answer is an emphatic “NO”.&lt;/p&gt;

&lt;p&gt;My main gripe with currently existing solutions is that they suffer from a lack of generality. Even though all of them deal with managing change in software development, each of them is applicable only to a small part of the process. This means that one must use very different tools to solve almost identical problems. The problem is further exacerbated by the fact that the various tools are very poor at communicating with each other.&lt;/p&gt;

&lt;p&gt;The lack of generality might best be illustrated by examining a “day in the life” of the typical programmer and their interactions with the various tools.&lt;/p&gt;

&lt;h2 id=&quot;editing-programs&quot;&gt;Editing programs&lt;/h2&gt;

&lt;p&gt;Our day starts with some actual &lt;em&gt;programming&lt;/em&gt;. In other words: by editing one or more computer programs in a text editor or IDE. Though we may not explicitly realize it, this brings us into contact with the first tool to manage change: the capabilities of our editor to &lt;em&gt;undo &amp;amp; redo&lt;/em&gt;: In all but the most basic editors each change we make in our program is separately recorded in the working memory and we can always roll back the changes we made in anti-chronological order.&lt;/p&gt;

&lt;p&gt;Note that the capability to undo implies that a historic record is kept. This record is what’s used to be able to revert to any given state of the document.&lt;/p&gt;

&lt;p&gt;The ability to undo is so useful that it’s hard to imagine an editor without it — &lt;a href=&quot;/the-power-of-undo/&quot;&gt;something that I’ve written about in another article&lt;/a&gt;. This article is also where some of the typical limitations of undo are described, such as the fact that your undo-history is lost when you close the editor and the fact that the only way to roll back changes is in often anti-chronological order. Such limitations are not the focus here, instead we’ll zoom in on the discontinuity between undo and other tools. To do so, we’ll start with version control.&lt;/p&gt;

&lt;h2 id=&quot;version-control&quot;&gt;Version control&lt;/h2&gt;

&lt;p&gt;Let’s return to a day in the life of a typical programmer. After successfully making a number of changes in our program these changes are typically &lt;em&gt;committed&lt;/em&gt; to a &lt;em&gt;source repository&lt;/em&gt; using a &lt;em&gt;version control system&lt;/em&gt;, i.e. using some command like &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Version control systems are those systems that we use to track changes to the source code of computer programs. Git is currently the most popular choice (overwhelmingly so), Mercurial is a less popular modern system and Subversion and CVS are older but still-in-use systems. Because tracking changes the explicit goal of version control systems the relationship with the present article should be quite obvious.&lt;/p&gt;

&lt;p&gt;Version control systems are extremely useful: they allow us to go back to older versions of our program, compare versions, record notes about the intent of particular changes and work together with multiple people on the same project, among other things.&lt;/p&gt;

&lt;p&gt;In the above discussion of &lt;em&gt;undo&lt;/em&gt; we established that the capability to undo implies that a full historic record of all recent changes is kept in the editor. In the present discussion we’ve noted that the programmer’s primary tool for keeping long term historic records is a version control system. As such, both version control systems and our editor’s ability to undo deal with the same thing, namely change to the source code of our program, focusing on the short and long term records of changes respectively. This raises a number of questions:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Why do we need two tools for the single task of history-keeping? Is there really a fundamental difference between short term changes and long term changes?&lt;/li&gt;
  &lt;li&gt;Can the two tools communicate with each other? Do they speak a single language?&lt;/li&gt;
  &lt;li&gt;What would either tool look like if it gained the capabilities of the other?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I’ll try to answer these in the below.&lt;/p&gt;

&lt;h3 id=&quot;one-task-two-tools&quot;&gt;One task, two tools&lt;/h3&gt;

&lt;p&gt;First let’s examine why we have two tools for a single task. Why do we need a version control system at all, if we already had a historic log of changes in our editor?&lt;/p&gt;

&lt;p&gt;The first potential reason is that the capabilities of the historic record associated with &lt;em&gt;undo&lt;/em&gt; are often quite limited. The record is lost when the editor is closed, the record cannot be cleaned up, annotated or shared. Those limitations are, however, not the fundamental reason; in principle they can be taken away by adding more capabilities to our editor.&lt;/p&gt;

&lt;p&gt;One could also argue that the reason for the split lies in the different meaning attributed to the different tools by the programmer. In this line of reasoning, the undo capabilities of the editor represent private and temporary changes. Only once some stable, tested and cleaned up state is reached this is committed to version control. In other words: the split in tools is caused by a fundamental semantic difference between “private / short term” and “public / long term”.&lt;/p&gt;

&lt;p&gt;Even if such a semantic split would exist, it would not amount to a fundamental reason for a split in tools: the ability to clean up the editor’s undo history could simply be improved. If the tooling for such cleanup would be powerful enough, a cleaned up version of the editor’s history could still be publicly shared.&lt;/p&gt;

&lt;p&gt;Furthermore, the idea that you should commit to version control only once you’re “fully done” runs somewhat contrary to the prevailing wisdom. One of the core ideas that distributed version control systems bring to the table is precisely that there may be many different levels of “doneness”, and that the tooling should provide abilities to house those different levels within a single system. Two such abilities are the ability to work on your own separate branch of history or to commit often and only rewrite your history before sharing it with others.&lt;/p&gt;

&lt;p&gt;In short: there is no fundamental divide between “short term history” and “long term history”, but rather a continuum, and a split in two sets of tools is not a fundamental property of nature.&lt;/p&gt;

&lt;p&gt;Instead, the fundamental reason that we have two tools for a single task follows from the non-central position we have given editors in the dominant paradigm of program construction. This paradigm is roughly the following:&lt;/p&gt;

&lt;p&gt;A computer program is compiled from a collection of source &lt;em&gt;files&lt;/em&gt;. How these files themselves are constructed is &lt;em&gt;not important&lt;/em&gt;, to the compiler they “just are”. In other words: we’re agnostic about our &lt;em&gt;means of construction&lt;/em&gt;, focusing only on &lt;em&gt;constructed&lt;/em&gt; artifacts.&lt;/p&gt;

&lt;p&gt;There are certainly arguments in favor of this paradigm: because we’re agnostic about the editor, each developer can use their own set of tools, and even a single developer can switch between various editors and other tools in the construction of the program.&lt;/p&gt;

&lt;p&gt;It’s worth noting, however, how dominant this implicit paradigm is, even in situations where it’s not necessarily the most fitting one. Consider for example that even an IDE that fully integrates the whole workflow of the programmer, including version management is bound by the same paradigm, even when the programmer never leaves the IDE and the capability to use different editors or tools is never actually used in practice.&lt;/p&gt;

&lt;p&gt;The drawbacks of this paradigm become obvious when considering that version control systems are bound by it too. From the perspective of the version control system, editors do not exist, only files. Each time a commit is made, the current state of all relevant files is inspected, and the VCS makes educated guesses as to how this evolved from the previous state.&lt;/p&gt;

&lt;h3 id=&quot;talking-tools&quot;&gt;Talking tools&lt;/h3&gt;

&lt;p&gt;Now that we know what the prevailing paradigm is, we can also answer the second question: Is any meaningful communication between the editor’s short term historic records and the long term historic records of the VCS possible?&lt;/p&gt;

&lt;p&gt;Obviously not! From the perspective of the VCS, we are agnostic about what an editor even &lt;em&gt;is&lt;/em&gt;, let alone that we could communicate with it. This means that the fine grained historic record stored by the editor will never be made available to the VCS, and will be lost forever.&lt;/p&gt;

&lt;p&gt;Let’s take a look at two examples where such information could in fact be useful:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Intra-commit chronology&lt;/strong&gt; — often it’s semantically meaningful to present the changes within a single commit in a particular logical order. The goal would be: when examining the changes introduced by the commit, it’s easier to understand these if they’re presented in a meaningful order than any random order.&lt;/p&gt;

&lt;p&gt;For example: when a function’s call signature is updated, all calling locations must also be updated. It makes sense to present such a change in exactly that order: first show the change in the definition; then show all calling locations being updated.&lt;/p&gt;

&lt;p&gt;This happens to be the same order in which such a change would typically be made by the original programmer. This is not a coincidence: the actual order of construction is often a good starting point in coming up with a good order in explaining a change.&lt;/p&gt;

&lt;p&gt;It would be great if our tools would:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;allow us to present the changes of a single diff in a logical order and&lt;/li&gt;
  &lt;li&gt;allow us to use the actual order in which we made changes the diff as a basis for this logical order — possibly cleaning up the actual result before presenting it to others.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;However, version management systems don’t have ordering inside a single commit, and they cannot communicate with editors to find out what this basis chronology could be.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Post-hoc commit splitting&lt;/strong&gt; — when committing changes to the VCS, it’s best practice to make &lt;em&gt;atomic commits&lt;/em&gt;, i.e. to ensure that each commit deals with only one single conceptual change. However, when editing a computer program it’s not always possible to be concerned with only one thing at at a time. For example, the change you’re working on might necessitate some other changes, leading you to get “sucked into a rabbit hole” of refactorings.&lt;/p&gt;

&lt;p&gt;If you happen to have made a large number of changes without intermediate commits, you’re left to your own devices to construct such atomic commits after the fact. This is typically done using “patch mode”, i.e. by manually marking various hunks of code as either part of either a given commit.&lt;/p&gt;

&lt;p&gt;However, in actuality, the changes that are about to be committed have been made in a particular order. In many cases, this actual chronological order could be of great help in the construction of the atomic commits. (This assumes that changes that were made consecutively are more likely to be related than non-consecutive changes, which is indeed usually the case). This chronological information lives in the editor’s undo history, but is unfortunately not available while constructing the patch.&lt;/p&gt;

&lt;h3 id=&quot;capabilities&quot;&gt;Capabilities&lt;/h3&gt;

&lt;p&gt;Version control systems are in many ways more powerful than most editors’ capabilities to undo. The third question is: consider what kind of capabilities could be gained by transposing the full expressiveness of version control systems to the undo history of the editor. In this transposition the granularity that’s currently associated with the undo command, namely that of the single edit-action, should be preserved. Here are two examples:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The ability to work together on a single project on two or more computers, currently only realistically possible on the granularity of a version control “commit”, would become available while editing the program with the granularity of a single keystroke. In other words: proper support for Pair Programming.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The ability to visually inspect, navigate through and manipulate the history of the edit-process would become available at a lower level than the commit. Note that the current standard capabilities of typical editors, namely the combination of undo &amp;amp; redo, makes for a rather incomplete navigational commands. Consider for example the case where you undo a large number of changes and then make a new change: in that scenario the undone changes can no longer be restored using the “redo” command. Having full navigation through history available, this problem disappears.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;package-management&quot;&gt;Package management&lt;/h2&gt;

&lt;p&gt;Back to a day in the life of our programmer. Let’s say the program under consideration depends on a number of external libraries. Such libraries may depend on a number of other libraries themselves, which may depend on further libraries etc, forming a &lt;em&gt;dependency graph&lt;/em&gt;. Furthermore, each of these dependencies is to some specific version or range of versions; we cannot generally assume that each version of each library works well with each library it depends on, so we must specify which versions are known to work correctly. Such a situation is a natural consequence of two simple facts of life: The ever-changing nature of programs and the justified desire of programmers to decompose their programs into submodules.&lt;/p&gt;

&lt;p&gt;The tools to resolve the various dependencies mentioned above are known as “package management systems”. They typically come in either one of two flavors. Firstly various Operating Systems bundle a package manager to do system-wide installations of software, Examples are &lt;code class=&quot;highlighter-rouge&quot;&gt;apt&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;yum&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;pacman&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;nix&lt;/code&gt;. Secondly there’s a great number of package management systems specific to a particular programming language — almost all programming languages seem to come with their own package manager (&lt;code class=&quot;highlighter-rouge&quot;&gt;pip&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;gem&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;cargo&lt;/code&gt;, to name just a few).&lt;/p&gt;

&lt;p&gt;One of of the main arguments of this article is that there are too many incompatible tools to deal with changing software. Regarding package management in particular, we can drive this point home in two ways. First, the sheer amount of different package management solutions is almost comical. One can also not help but wonder why so many tools of the same kind are necessary, and whether this is not an indication of a fundamental flaw in their design. Second, the fact that package managers are not only poorly able to talk with other tools for managing change, but can hardly speak among themselves, is a further indication of a deep problem.&lt;/p&gt;

&lt;p&gt;On the subject of inter-operation with other tools for managing change the following: Note that package management is yet another tool to deal with changing software, albeit with a slightly different focus than version control systems. The capabilities that each of the tools lack with respect to the other follow directly from this different focus:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Package management deals with the dependencies on and between a number of external “packages” which are taken more or less as a given. Package management systems have only very limited support for tracking history inside a single package. Some of the primary operations of version management systems, such as constructing histories, comparing versions and cooperating in teams are missing.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Version control systems, on the other hand, deals with a single repository of code under control of the user. This means that they lack the ability to naturally track versions across composed systems in a composed manner. Even though git offers some workarounds for this, such as &lt;code class=&quot;highlighter-rouge&quot;&gt;gitmodules&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;git-subtree&lt;/code&gt;, such workarounds are fundamentally limited, for example because it’s not possible to arbitrarily nest them.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Version control systems’ assumption that there is a single repository of code forces the programmer to make a rather arbitrary decision: what is the single thing whose history they want to track? Possible choices are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Putting the entire company’s software development efforts in a single repository. Drawback: This conflates various tools and programs that may be entirely unrelated.&lt;/li&gt;
  &lt;li&gt;Identifying “projects” and giving each project (including its modules) its own repository. Drawback: The projects may in fact contain multiple modules that are reused across multiple projects; including their history as a part of one or more particular projects will make it harder to reuse improvements across projects.&lt;/li&gt;
  &lt;li&gt;Breaking up the projects into modules and managing each module’s history independently. Drawback: the relationship between changes to programs and their modules is hard to express.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each of the mentioned choices will have some drawbacks. This is only natural: the ability to recursively decompose programs into smaller sub parts is one of the core values of programming, so if we do away with it (as version control systems do) we will run into trouble immediately!&lt;/p&gt;

&lt;p&gt;Taking inspiration from package management tools, we could imagine a form of composable version management: the ability to manage the history of an arbitrary sub part of a program, while preserving the ability to have an integrated view of the history of any component that combines a number of parts.&lt;/p&gt;

&lt;p&gt;Taking such an approach to its radical extreme we can make the parts almost arbitrarily small or big: tracking the history of expressions, statements, methods, classes, modules, programs and systems, whereby each level of history is expressed as a composition of the histories at lower levels. The consequences of such an approach will be further explored in a later article.&lt;/p&gt;

&lt;p&gt;As far as I can see, version management with decent capabilities for composition would render package management tools entirely obsolete. For that reason the consequences of applying the ideas of VCSes to package management are not explored here.&lt;/p&gt;

&lt;h2 id=&quot;other-examples&quot;&gt;Other examples&lt;/h2&gt;

&lt;p&gt;There are a great number of other tools that deal with changing programs; They are mentioned here mostly to give an indication as to the quantity of such tools. I might explore the possible inter-relationships between them in a follow-up article.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Data/schema-migrations&lt;/strong&gt; — When the program is changed, its expectations about the data it interacts with may also change. For the case that the data is stored in a database, the tools to migrate data are usually called “data migrations” or “schema migrations”. Similar cases are that of a newer version of the program that expects a different configuration file format, and the case of a program that simply changes its document-format.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Provisioning &amp;amp; Containers&lt;/strong&gt; — tools such as &lt;code class=&quot;highlighter-rouge&quot;&gt;chef&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;puppet&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;ansible&lt;/code&gt; are often used when managing environments of similarly configured machines. They deal with many of the same challenges as package managers: getting the right versions of the right dependencies in the right place. Similar remarks can be made about &lt;em&gt;containers&lt;/em&gt; (Docker being a currently popular solution): one might say that their greatest value is in being able to precisely reproduce an entire environment of dependencies to a specific set of versions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Build tools&lt;/strong&gt; — build tools such as &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;maven&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;ant&lt;/code&gt; take responsibility for the compilation of larger programs. They relate to change in software in the sense that [a] they’re responsible for detecting which parts of the system have changed, and must therefore be rebuilt and [b] they may specifically talk about particular versions of dependencies of the build.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;There is a large amount of tools to manage the ever-changing nature of software.&lt;/p&gt;

&lt;p&gt;One could argue that this is an indication that we’re dealing with a solved problem and that further thinking about &lt;em&gt;Expressions of Change&lt;/em&gt; is not required.&lt;/p&gt;

&lt;p&gt;Personally, I’m taking as an indication of the opposite; I’m especially emboldened by the fact that the various tools cannot even properly talk to each other, despite them being (largely) dealing with problems in the same sphere.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/existing-tools/&quot;&gt;Existing tools&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on June 27, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[The power of Undo]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/the-power-of-undo/" />
  <id>http://expressionsofchange.com/the-power-of-undo</id>
  <published>2017-06-14T00:00:00+02:00</published>
  <updated>2017-06-14T00:00:00+02:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;p&gt;Let’s why this could be so, by considering the following workflow:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A person is interacting with a computer system with certain goals in mind&lt;/li&gt;
  &lt;li&gt;They try to express these goals in the language of the system, by issuing certain commands.&lt;/li&gt;
  &lt;li&gt;If the command brings you closer to the goal issue another one.&lt;/li&gt;
  &lt;li&gt;If the command brings you further from the goal:
    &lt;ol&gt;
      &lt;li&gt;If undo is available as a command, undo.&lt;/li&gt;
      &lt;li&gt;If undo does not exist, it’s not clear how to back on track - and even whether getting back on track is possible at all!&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In other words: the ability to undo amounts to an enormous increase of &lt;em&gt;control&lt;/em&gt; of the human actor over the system they are commanding, by allowing them to to roll back mistakes, even potentially very destructive ones.&lt;/p&gt;

&lt;p&gt;This increase of control has a 1-to-1 mapping with a decrease in &lt;em&gt;fear&lt;/em&gt;: the more sure you are that you can always undo mistakes, the less afraid you will be to make them. Such fear is most obviously visible when observing at those with low computer literacy in their interactions with computers, but it applies to everyone. This very emotion then hinders further learning, because it stands in the way of experimenting and gaining feedback about the way the system works.&lt;/p&gt;

&lt;p&gt;Note that the increase of control and decrease of fear that undo brings is available even when your further knowledge of the system is very limited - as long as you’re confident that you can undo any action, you’re free to explore. In other words: Undo brings control in face of the unknown - quite a capability indeed!&lt;/p&gt;

&lt;p&gt;By the way: the capability to undo is a typical example of an &lt;em&gt;Expression of Change&lt;/em&gt; - the actions to be undone being the change about which we express ourselves.&lt;/p&gt;

&lt;h2 id=&quot;common-limitations&quot;&gt;Common limitations&lt;/h2&gt;

&lt;p&gt;Given how powerful the ability to undo is it’s worthwhile examining if it can be made even more powerful. To do so, let’s look at some limitations that typically apply in common desktop applications. The definition of “typically” is obviously up for debate, and thankfully there are many applications which do not suffer from one or more of the below limitations. In any case, “single undo only” and “no redo” are not mentioned below because most reasonably modern applications have virtually infinite undo as well as the ability to redo.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Discard on close&lt;/strong&gt; - the ability to undo is lost when closing and reopening your editor. You may be able to save documents, but saving documents including their full undo history is not possible.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Lack of discoverability&lt;/strong&gt; - the ability to undo is offered as a menu option and keyboard shortcut, but the historic record of changes cannot itself be inspected visually, saved or manipulated.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Linear undo only&lt;/strong&gt; - the ability to undo is only available in anti-chronological order, i.e. by undoing the last change first, the second last second etc. It’s not possible to undo (or even more powerfully: edit) arbitrary changes in the past without undoing all follow-ups first.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;No redo after do&lt;/strong&gt; - when undoing a number of changes, and then making an arbitrary new change, the undone changes can no longer be redone. In other words: the state your document was in before undoing is not always reachable after the undo. Equivalently: the action of undo itself cannot always be undone.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Monolithic context&lt;/strong&gt; - each document has a single undo history; when the document is composed of multiple parts or sections these do not have their own histories. Similarly, when multiple documents form a conceptual unit, such as the source tree of a computer program, undo is not available across documents but only at the level of a single document.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Undo is great, let’s have more of it.&lt;/p&gt;

&lt;p&gt;We seen what limitations commonly apply in currently existing applications.&lt;/p&gt;

&lt;p&gt;The challenge of this site is then simply: to come up with undo-like capabilities that don’t suffer from these limitations, like so:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Undo after close&lt;/strong&gt; - the ability to undo is preserved even after the application has crashed or has been closed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Change as a first level citizen&lt;/strong&gt; - the historic record can be inspected, saved and manipulated like any other object in our system.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Arbitrary graph traversal&lt;/strong&gt; - we have the ability to revert to any state of the document as it once existed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Decompositon of context&lt;/strong&gt; - for structured documents undo is available on arbitrary parts of the document, parts consisting of other parts, and the document as a whole.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This site documents work in progress; stay tuned for updates.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/the-power-of-undo/&quot;&gt;The power of Undo&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on June 14, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Self applicability]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/self-applicability/" />
  <id>http://expressionsofchange.com/self-applicability</id>
  <published>2017-06-10T00:00:00+02:00</published>
  <updated>2017-06-10T00:00:00+02:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;p&gt;We’ll take a look at the practice of &lt;em&gt;rewriting history&lt;/em&gt;, why we would want to do that and how it creates two seemingly irreconcilable goals: staying true to what actually happened on the one hand and the ability to tell the most clear story about history on the other. Then we’ll see how we can reconcile these goals by applying the idea of version control to version control itself.&lt;/p&gt;

&lt;h2 id=&quot;editing-programs&quot;&gt;Editing Programs&lt;/h2&gt;

&lt;p&gt;To be able to properly discuss all this, we’ll start at the very beginning: by examining some very minimal examples of the construction of a computer program.&lt;/p&gt;

&lt;p&gt;To describe these, we’ll use pen, paper, an eraser and a pair of scissors - this way everything stays simple and visual. Note that this description is no less general than the usual process of constructing programs on an actual computer: wherever we talk about “pieces of paper”, we can simply substitute “one or more files”.&lt;/p&gt;

&lt;p&gt;Say that on a given Monday we’re given the task to write a simple program. We do so by writing this on our piece of paper and call it a day.&lt;/p&gt;

&lt;p&gt;At some point soon after, let’s say on Tuesday, the need arises for a more advanced program. We erase part of our program and add some new parts to reflect this, like so:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/movies/editing-programs.gif&quot; alt=&quot;Editing a program.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now, if we discover a bug in our program on Wednesday, we’re faced with a problem: we cannot simply go back to Monday’s version of the program, because it no longer exists. Nor can we compare Monday and Tuesday’s versions to reason about them.&lt;/p&gt;

&lt;p&gt;This is caused by the fact that changing the program brings with it the loss of information. This is particularly obvious in our example because we’re literally erasing part of the first program to write the second. Note however that even if we only ever add to the program, we destroy the knowledge of what the program looked like before the additions.&lt;/p&gt;

&lt;h2 id=&quot;version-control&quot;&gt;Version Control&lt;/h2&gt;

&lt;p&gt;To be able to keep the old versions around we could use a modern Version Control System such as Git. In addition to the ability to go back or forward to an arbitrary version of the program, this will allow us to compare versions, work together with other people and merge diverging lines of development.&lt;/p&gt;

&lt;p&gt;In our pen &amp;amp; paper world we will model Version Control by using an extra piece of paper. On this we draw the versions of the program as nodes, annotate these with some meta-data (date, author, description), and connect them by arrows into a directed acyclic graph that describes the history of the program.&lt;/p&gt;

&lt;p&gt;The graph may be constructed by copying a given current state of the program over to this second piece of paper and adding the relevant metadata. This corresponds to a &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can then navigate through this graph by pointing at a given node with our finger (below: a big red arrow), and copying the node’s content over into the current program state. This corresponds to a &lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout&lt;/code&gt;. Because we always have the full history available, we’ve solved our initial problem!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/movies/version-control.gif&quot; alt=&quot;Version Control&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;rewriting-history&quot;&gt;Rewriting History&lt;/h2&gt;

&lt;p&gt;An important value for a historic record is its historic accuracy: the fact that it precisely reflects what actually happened. In Version Control as discussed so far, historic accuracy is guaranteed by the means of construction of the historic record. There are various versions of the program, and they each get added to the graph as they are created.&lt;/p&gt;

&lt;p&gt;In the toy example above we established the need for Version Control by talking about a simple means of going back in time. In larger projects, the historic information becomes more than a simple time machine: it becomes a repository of knowledge about the history of the project, offering insight in questions of intent. This value is further enhanced by best practices such as writing meaningful descriptions for each version and ensuring a single version contains only a single set of related changes. In the light of this role, another value for a historic record emerges: the clarity of the record - records that are more clearly understandable by users being better than ones that are hard to understand.&lt;/p&gt;

&lt;p&gt;Sometimes the values of accuracy and clarity are at odds with each other: most clear story about history is not told by the description of history as it actually happened, but rather by some simplification or cleanup. In such cases a may be useful to &lt;em&gt;rewrite history&lt;/em&gt;. Here are some examples of such rewrites with their equivalent &lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt; commands:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;If you make a mistake while adding a version to the historic record, you may want to fix the mistake in the record rather than adding yet another version to fix the mistake (such a version would only clutter the record). (&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit --ammend&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;History is not always linear; multiple new version may arise based on a single version of the program. Such diverging histories can later be merged together in a separate “merge” version. However, many such separate version will clutter up the historic record, and are therefore sometimes deemed undesirable. The solution is to rewrite history as if the divergence never took place: one of the diverging branches of history is cut from its actual base, rewritten, and pasted at the tail of the other branch in a single linear fashion. (&lt;code class=&quot;highlighter-rouge&quot;&gt;git --rebase -i&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;An animation of a &lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt; in our pen &amp;amp; paper world is shown below: the commit “C” is rewritten as if it happened after “B”, rather than independently of it; this simplifies the graph because we no longer need a merging commit.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/movies/rewriting-history.gif&quot; alt=&quot;Rewriting History&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As should be obvious from these two examples, rewriting of history can be quite helpful in increasing the clarity of the historic record by removing clutter in the form of irrelevant details. It does, however, come at a price; one which is hinted at by the use of scissors in the animation.&lt;/p&gt;

&lt;p&gt;Firstly, it violates precisely the goals as stated in the initial example: a true historic record without loss of information. This is not merely a theoretical problem: consider the case of a rebased version which has some kind of bug. For such a bug it is impossible to say whether it was introduced as a direct consequence of the rebasing or was also present in the unrebased version. Given that such understanding is precisely what version control is about, this is really unfortunate.&lt;/p&gt;

&lt;p&gt;Secondly, consider the fact that version control forms an important safety net in our software development process: when we make mistakes we can undo them by going back to an older version. However, while rewriting history we don’t have the capability of reverting mistakes made in the rewriting process itself. This is precisely why most blog articles about rewriting of history in Git are annotated with big red warning boxes.&lt;/p&gt;

&lt;p&gt;So far we’ve seen two seemingly irreconcilable goals: “true history” and a “clear history”. Because the goals are presented as an either/or choice, striking some balance is left as a matter of culture or taste to individual users and teams. It has been my personal observation that users of Mercurial often err on the side of accuracy, whereas users of Git prefer clean histories, but your mileage may vary.&lt;/p&gt;

&lt;h2 id=&quot;self-applicable-version-control&quot;&gt;Self Applicable Version Control&lt;/h2&gt;

&lt;p&gt;The question that seems to remain unasked is: is it be possible to have a historic record that’s both truthful to what actually happened and a clear description that leaves out irrelevant details?&lt;/p&gt;

&lt;p&gt;To answer this, let’s go back to the running example of keeping track of our program and the history of our program on a piece of paper. So far we’ve seen the following:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The Program
    &lt;ol&gt;
      &lt;li&gt;A piece of paper may be used to write a program.&lt;/li&gt;
      &lt;li&gt;At some point new features are requested, and we must edit the program.&lt;/li&gt;
      &lt;li&gt;Once we do this lose information about previous versions of the program.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Version Control
    &lt;ol&gt;
      &lt;li&gt;A piece of paper may be used to keep track of a historic graph of all programs from step 1.&lt;/li&gt;
      &lt;li&gt;It may be useful to clean up this graph by rewriting history for reasons of clarity.&lt;/li&gt;
      &lt;li&gt;Once we edit the historic graph we lose information about previous versions of the history.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We’ve seen that the problem mentioned in step 1c was solved by step 2a; and that we have an as of yet unsolved problem in step 2c. The question then is: can we think of a step 3a to solve this?&lt;/p&gt;

&lt;p&gt;Sure: we can simply add yet another piece of paper containing a historic graph, just like we did in step 2a. The only difference being the content of the nodes of the graph: rather than keeping track of individual programs, we can track the history of historic graphs. Let’s call this graph a 2nd level history.&lt;/p&gt;

&lt;p&gt;Construction of this graph is analogous to the construction of the regular historic graph: whenever we change the historic record, we add a full copy of the historic graph to the second-level history as a node. We do this both for any history writing operations (such as a &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt;) as for rewriting operations (such as &lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Just like in the case of regular Version Management we can navigate through the newly constructed graph. Navigation through a second level history corresponds to changes in the historic graph (rather than changes to the program). In other words: it corresponds to rewrites of history. Here it is in action:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/movies/vcs-squared.gif&quot; alt=&quot;History of History&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Note that we’ve achieved our goal now! We can rewrite our first level history to be as clear as possible, while keeping a record of precisely what actually happened available in our second level history. This gives us the ability to un-rewrite history just as easily as reverting back to a previous version of our program.&lt;/p&gt;

&lt;p&gt;We did this simply by applying the idea of Version Control on itself: we use Version Control on graphs representing Version Control. This is hardly a unique idea in the field: other examples are using compilers to compile compilers and applying functions to functions to yield further functions.&lt;/p&gt;

&lt;h2 id=&quot;down-the-rabbit-hole&quot;&gt;Down the rabbit hole&lt;/h2&gt;

&lt;p&gt;Now that we’ve seen that the concept of tracking change is self-applicable, we may ask how often we may want to self-apply. Is it possible to talk about third or nth level histories, i.e. histories of histories of histories or even deeper levels? Secondly: is there any use for such expressions?&lt;/p&gt;

&lt;p&gt;The first question is easily answered: yes, we can always keep adding more layers. Any Version Control which doesn’t care what’s under control can always be used to wrap an &lt;em&gt;n - 1&lt;/em&gt; level history to yield an &lt;em&gt;n&lt;/em&gt; level history.&lt;/p&gt;

&lt;p&gt;Now for the second question: are such deep self-applications of any use? To this, I do not yet know the answer.&lt;/p&gt;

&lt;p&gt;In general, to get the advantages of Version Control in all parts of your system, you need precisely one more level of history than the amount of levels on which you want to make potentially destructive changes.&lt;/p&gt;

&lt;p&gt;So far, we’ve seen that making of destructive changes on the first level of history (“rewriting history”) is occasionally quite useful, and that we may therefore want to introduce a second level of history.&lt;/p&gt;

&lt;p&gt;Because we lack actual experience with such a second level history, use cases for destructively editing that have not yet shown themselves. It may be that they don’t actually exist; in which case we’re done. If they do, a third level might be useful. In any case, it would seem that for each level the amount of usage decreases, an that we at some point run out of the need for further levels.&lt;/p&gt;

&lt;h2 id=&quot;self-applicable-git&quot;&gt;Self-applicable Git&lt;/h2&gt;

&lt;p&gt;Implementing the above insights using a typical modern Version Control System such as Git does, unfortunately, not lead to very useful results.&lt;/p&gt;

&lt;p&gt;This is caused by the following: In the above we made no assumptions about the nature of the pieces of paper - other than that they could be stored as a file on a computer.&lt;/p&gt;

&lt;p&gt;Git and comparable systems, on the contrary, do make specific assumptions: most modern Version Control systems are built on the assumption that the files they are tracking are almost exclusively text files.  Even though storing the occasional small binary file is certainly technically possible, storing large numbers of large binary files in Git is certainly not recommended, and will not lead to a workable system.&lt;/p&gt;

&lt;p&gt;The Git repository itself is implemented precisely as a collection of binary files. This means that tracking the history of a Git repository cannot be done efficiently using Git.&lt;/p&gt;

&lt;p&gt;In fact: trying this one runs into the fact that adding Git repositories to be tracked inside other repositories has been explicitly forbidden: git repositories are managed using a directory called &lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt;, and Git raises an error when presented with a directory named &lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt; to track.&lt;/p&gt;

&lt;h2 id=&quot;implementation-hint&quot;&gt;Implementation hint&lt;/h2&gt;

&lt;p&gt;In the pen-and-paper examples of this article, the trackable items of interest (whether computer programs or complete n-histories) were always presented as files. Tracking such files was presented as adding the full state at any given point in time as a historic node to the graph.&lt;/p&gt;

&lt;p&gt;This approach does not generally scale to n-level histories: the storage requirements at each level grow like so:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;the 1-history stores all programs, i.e. growth linearly with program size and version count.&lt;/li&gt;
  &lt;li&gt;the 2-history stores all 1-histories, i.e. growth linearly with [1] and version count.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In this approach, the storage requirements for a given n-history’s are &lt;em&gt;O(p * v&lt;sup&gt;n&lt;/sup&gt;)&lt;/em&gt;. (&lt;em&gt;p&lt;/em&gt; for program size, &lt;em&gt;v&lt;/em&gt; for number of stored versions and &lt;em&gt;n&lt;/em&gt; for n-level-history)&lt;/p&gt;

&lt;p&gt;An important observation is that the actual (human) user actions that give rise to this growth is much more limited. The actual things the user can do are limited to:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Make direct changes to the program.&lt;/li&gt;
  &lt;li&gt;Calling various commands of (a n-level) Version Control system&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If we only store such user-actions into the various levels of Version Control, we’ll get a system that scales linearly with user input.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next steps&lt;/h2&gt;

&lt;p&gt;In this article I’ve shown (hopefully) how applying the ideas of Version Control on their own data-structures can be quite useful.&lt;/p&gt;

&lt;p&gt;We’ve also seen that having the property of self-applicability is not a given - e.g. Git cannot meaningfully be applied on Git repositories.&lt;/p&gt;

&lt;p&gt;I expect to be adding some example programs to this site at some point in the future. Inasmuch as those programs will be like Version Control systems, the ability to self-apply is an important design goal.&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/self-applicability/&quot;&gt;Self applicability&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on June 10, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Build once, maintain forever]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/build-once-maintain-forever/" />
  <id>http://expressionsofchange.com/build-once-maintain-forever</id>
  <published>2017-06-07T00:00:00+02:00</published>
  <updated>2017-06-07T00:00:00+02:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;p&gt;Now, you would like to just be able to build this site once, and once you’re satisfied with it, put it somewhere and be done with the technical side of things forever. Any maintenance to the site should then be restricted to updating the actual contents of the site.&lt;/p&gt;

&lt;p&gt;This is, as it stands, impossible: to be somewhat confident the site doesn’t get hacked, you need to run regular upgrades of the software the site was built on (Operating System, Database technology, Web Frameworks etc. etc.) Any of these upgrades may bring down the site, so they must to some degree be manual. At the very least you must always check whether the upgrade was successful, and if it wasn’t, you’ll need to manually figure out why it wasn’t and somehow fix it (again: manually).&lt;/p&gt;

&lt;p&gt;The reason for this is that the upgraded software libraries will work in slightly different ways from their predecessors, breaking the expectations of your software. This can be mitigated, but only to a degree.&lt;/p&gt;

&lt;p&gt;Firstly, the maintainers of the libraries may provide specific “security support” for specific older versions of their libraries. By restricting the upgrades of libraries to such security upgrades, which are smaller in both number and scope, you will certainly reduce the amount of required manual intervention. Unfortunately, even “security upgrades” are not guaranteed to be free from breakage, so manual intervention cannot be ruled out completely. Furthermore:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Security support for older versions is not eternal&lt;/li&gt;
  &lt;li&gt;The challenge of doing only minimal upgrades is made harder by the fact that the various libraries we build on may have dependencies amongst themselves&lt;/li&gt;
  &lt;li&gt;Our “package manager” may introduce further constraints on the available versions of libraries&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In any case, once the security support stops, you’ll have to do the regular upgrades after all, and you’ll still be confronted with the full scope of the original problem.&lt;/p&gt;

&lt;p&gt;A second way to mitigate the problem of running upgrades is to offload part of the work to other parties. You may, for example, rent a platform of up to date software; leaving the upgrading of the platform to an external party.&lt;sup id=&quot;fnref:saas-iaas&quot;&gt;&lt;a href=&quot;#fn:saas-iaas&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; In some cases, such an approach will actually create further problems of its own, for example when your infrastructure provider decides to apply upgrades which are incompatible with your software, and does so while you’re sleeping. The more fundamental issue is that paying someone else to do part of the work is merely hiding the real problem, which is that the work exists in the first place.&lt;/p&gt;

&lt;p&gt;In short: the state of the art of running a small website is “build once, manually maintain forever”. This burden of maintenance is largely caused by changes in &lt;em&gt;other software&lt;/em&gt;, as opposed to changes in our own requirements.&lt;/p&gt;

&lt;p&gt;The project on this website is to come up with (experimental) solutions for this problem and others. This is an ongoing project.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:saas-iaas&quot;&gt;
      &lt;p&gt;Arguably that the popularity of Software as a Service and Infrastructure as a Service is further evidence for the case: the unmanageability of software upgrades is so big that it has created a market of its own! &lt;a href=&quot;#fnref:saas-iaas&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;

  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/build-once-maintain-forever/&quot;&gt;Build once, maintain forever&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on June 07, 2017.&lt;/p&gt;</content>
</entry>

</feed>
