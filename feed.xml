<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
<title type="text">Expressions of Change</title>
<generator uri="https://github.com/mojombo/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="http://expressionsofchange.com/feed.xml" />
<link rel="alternate" type="text/html" href="http://expressionsofchange.com" />
<updated>2017-06-29T14:45:39+02:00</updated>
<id>http://expressionsofchange.com/</id>
<author>
  <name>Klaas van Schelven</name>
  <uri>http://expressionsofchange.com/</uri>
  <email>klaas@vanschelven.com</email>
</author>


<entry>
  <title type="html"><![CDATA[Introducing the Editor]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/introducing-the-editor/" />
  <id>http://expressionsofchange.com/introducing-the-editor</id>
  <published>2017-06-29T00:00:00+02:00</published>
  <updated>2017-06-29T00:00:00+02:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;p&gt;The proposed alternative is to make &lt;em&gt;changes to programs&lt;/em&gt; the primitive building blocks, instead of the &lt;em&gt;programs that result from such changes&lt;/em&gt;. In this view, the means of construction are seen as equally important as the constructed artifacts. The idea is simply that, to be able meaningfully to reason about change, it is easier to keep the actual change at hand than to guess what it might have been.&lt;/p&gt;

&lt;p&gt;The decision to abandon text files as a possible input format has an important consequence for the roadmap of this project: editors that create text files are plentiful, but the type of editor that could be used to create changes as a primitive has yet to be designed. The first step in the project is therefore to design and implement such an editor.&lt;/p&gt;

&lt;p&gt;This will allow us to get some feedback on what works and what doesn’t, and on what the major challenges for such an editor are.&lt;/p&gt;

&lt;p&gt;Also, importantly, it will allow us to actually create the inputs for the yet to be designed programming language.&lt;/p&gt;

&lt;p&gt;In the below, we will sketch some important properties of such an editor.&lt;/p&gt;

&lt;h3 id=&quot;means-of-combination&quot;&gt;Means of combination&lt;/h3&gt;

&lt;p&gt;The first goal for our editor was mentioned already: the changes to programs shall be primitive entities in our editor. The second goal is that it shall be possible to combine these primitives in meaningful ways.&lt;sup id=&quot;fnref:sicp&quot;&gt;&lt;a href=&quot;#fn:sicp&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;The most straightforward such combination is to take of a linear sequence of such changes; we’ll call this a “history”.&lt;/p&gt;

&lt;p&gt;A more subtle means of combination arises when editing hierarchically structured documents, such as computer programs. Hierarchical documents, by definition, compose larger parts out of smaller parts. This leads to the question: how do the histories of the parts relate to their sub-parts?&lt;/p&gt;

&lt;p&gt;For the editor presented below, the answer is: the histories between relate in a meaningful way. In particular, the history of some part of our program will be composed of the histories of its subparts.&lt;/p&gt;

&lt;h3 id=&quot;structured-editing&quot;&gt;Structured editing&lt;/h3&gt;

&lt;p&gt;In the above we’ve established three things: first that we need to create an editor for computer programs, second that changes shall be its primitives and third that histories of changes shall be meaningfully composable along the lines of the document’s structure.&lt;/p&gt;

&lt;p&gt;These goals point strongly in the direction of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Structure_editor&quot;&gt;structured editor&lt;/a&gt;, meaning an editor that is aware of the document’s structure. There are two main reasons for this:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;To establish a good inventory of primitive operation of change: If we would treat the structure of the edited document as a black box, we could not say anything meaningful about changes to it. We must thus take the opposite approach and acknowledge the document’s structure.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;To be able to compose and decompose histories along structural lines — that we need to acknowledge the document’s structure to be able to do this should be obvious.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Incidentally, structured editing brings with it many other advantages: certain classes of incorrect programs cannot be constructed, there is no need to write a parser, meaningful reporting on errors is much easier etc. etc. We shall gladly make use of such advantages, but they are not the initial cause for the decision.&lt;/p&gt;

&lt;p&gt;Finally, note that the decision to create a structured editor rather than an unstructured one incurs no extra cost on our implementation. Because a radical departure from the main paradigms of text editing is the starting point of our design, we are free to drop any defaults from that paradigm, such as the fact that everything is unstructured text.&lt;/p&gt;

&lt;h3 id=&quot;structure-s-expressions&quot;&gt;Structure: S-Expressions&lt;/h3&gt;

&lt;p&gt;So far we have established that the editor to be is to be a structured editor and that its primitives will be the changes to some structure. Now then, before we can turn our attention to those primitives, we must first decide what that structure looks like.&lt;/p&gt;

&lt;p&gt;For the first prototype, I have decided on the simplest thing that could possibly work: &lt;a href=&quot;https://en.wikipedia.org/wiki/S-expression&quot;&gt;s-expressions&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;S-Expressions are&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;an atom (some symbol), or&lt;/li&gt;
  &lt;li&gt;a list of 0 or more s-expressions&lt;sup id=&quot;fnref:lists-not-tuples&quot;&gt;&lt;a href=&quot;#fn:lists-not-tuples&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With these two types of elements we can build tree like structures with at the leaves either empty lists or atoms.&lt;/p&gt;

&lt;p&gt;The primary motivation for picking such a minimal syntax is a practical one: the scope of the project is rather large as it stands and a programming language family which is expressed in S-Expressions is readily available (&lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot;&gt;LISP&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;From a usability perspective, S-Expressions are also desirable. There are only two kinds of S-Expression (atoms &amp;amp; lists) and the mapping between S-Expressions and their visual representation is very straightforward. Since the structure of the program is readily visible, the programmer needs not create a separate mental model of it in their head; this makes structured editing feasible.&lt;/p&gt;

&lt;p&gt;Most advances in programming language research in the last few decades, most notably in type systems, have been made in &lt;a href=&quot;https://en.wikipedia.org/wiki/ML_(programming_language)&quot;&gt;ML&lt;/a&gt; and its derivatives. To be able to incorporate those while retaining elegance an upgrade to a less minimal syntax may be required at some point. However, for the first version of the editor a minimal syntax is sufficient — the focus on change as a primitive will yield sufficient insights to make the experiment worthwhile.&lt;/p&gt;

&lt;h3 id=&quot;a-clef-for-construction&quot;&gt;A Clef for Construction&lt;/h3&gt;

&lt;p&gt;Having established what the structure of our documents will be, we can turn our attention to the primitives of construction. In other words, we’ll have to decide on a set of operations to construct and modify S-Expressions. We’ll call such a set of primitives a &lt;em&gt;Clef&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This is just as much a design decision as picking the syntax of the language in the first place. Here too, the space from which we can choose is infinite.&lt;sup id=&quot;fnref:infinite-space&quot;&gt;&lt;a href=&quot;#fn:infinite-space&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; The forces working on this decision are similar too; they are roughly:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Adding more elements to the &lt;em&gt;clef&lt;/em&gt; potentially allows for more precise descriptions of history and expressions of intent (good).&lt;/li&gt;
  &lt;li&gt;Adding more elements imposes an implementation cost (bad).&lt;/li&gt;
  &lt;li&gt;Adding more elements imposes a mental burden on the programmer (bad).&lt;/li&gt;
  &lt;li&gt;Adding more elements increases the risk that multiple mechanisms exist to construct the same result, without being able to assign a different semantics to these mechanisms (bad).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the below I will present a particular clef as decided upon (for now); leaving the description of the thought-process of the decision itself to another (yet to be written) article.&lt;/p&gt;

&lt;p&gt;The clef defines the following operations:&lt;sup id=&quot;fnref:imperative-functional-equivalence&quot;&gt;&lt;a href=&quot;#fn:imperative-functional-equivalence&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;BecomeAtom atom&lt;/code&gt; — Out of nothingness, spawn a given atom; or replace an existing atom with the given atom.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;BecomeList&lt;/code&gt; - Out of nothingness, spawn an empty list.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Insert index history&lt;/code&gt; For a list, insert at the index the s-expr that can be constructed from the history; shifting items to the right as required.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Delete index&lt;/code&gt; — For a list, delete the element at the index; shifting items to the left as required.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Replace index history&lt;/code&gt; — For a list, replace the element at the index with the s-expr that can be constructed from the history.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using this clef we can both construct any s-expressions from scratch and modify any given s-expression into any other (a formal proof is left as an exercise to the reader). As an example, consider a possible way to construct the s-expression &lt;code&gt;(+ (* 6 9) 12)&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;BecomeList&lt;/code&gt; — starting with an empty list expression&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Insert 0 (BecomeAtom +))&lt;/code&gt; — as the first item, insert the history which consists of the creation of the atom &lt;code&gt;+&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Insert 1 ...&lt;/code&gt; — as the second item, insert the result of the following history:
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;BecomeList&lt;/code&gt; — starting with an empty list (sub)expression&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Insert 0 (BecomeAtom *))&lt;/code&gt; — introducing the atoms one…&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Insert 1 (BecomeAtom 6))&lt;/code&gt; — by one…&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Insert 2 (BecomeAtom 9))&lt;/code&gt; — by one.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Insert 2 (BecomeAtom 12))&lt;/code&gt; — similar to the construction of &lt;code&gt;+&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The above example is quite trivial, because the order of construction is precisely identical to the ordering of the result. In practice the order might be quite different, and might also include deletions (and therefore: insertions whose effects are not visible in the final result).&lt;/p&gt;

&lt;p&gt;Another history leading to the same result is shown below. Note that the indices are not the same as in the first example, but the result is the same.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;BecomeList&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Insert 0 (BecomeAtom 12))&lt;/code&gt; — we start with a single element &lt;code&gt;12&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Insert 0 (BecomeAtom +))&lt;/code&gt; — to the left of it, we introduce the &lt;code&gt;+&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Insert 1 ...&lt;/code&gt; — assuming the same history on the ellipses as in the first example&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Importantly, the clef also allows us to express the histories of larger parts of our document as being composed of the histories of their subparts.&lt;/p&gt;

&lt;p&gt;To see how this is so, consider the following: The s-expressions form a tree. If the history of a given node is extended by some change, we can apply &lt;code&gt;Replace&lt;/code&gt; on its parent node, providing the node’s index in the parent and the extended history. Because this &lt;code&gt;Replace&lt;/code&gt; represents a change at the level of the parent, we can repeat this process until we reach the root of the tree. Using this mechanism, the same example might look like this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;BecomeList&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;Insert 0 (BecomeAtom +))&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Insert 1 ...&lt;/code&gt; — We start by adding an empty sub-expression…
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;BecomeList&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Replace 1 ...&lt;/code&gt; — which is then extended with &lt;code&gt;*&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;BecomeList&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Insert 0 (BecomeAtom *))&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Replace 1 ...&lt;/code&gt; — and extended with &lt;code&gt;6&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;BecomeList&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Insert 0 (BecomeAtom *))&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Insert 1 (BecomeAtom 6))&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;Insert 2 (BecomeAtom 12))&lt;/code&gt; — intermezzo on the top-level&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Replace 1 ...&lt;/code&gt; — and extended with &lt;code&gt;9&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;BecomeList&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Insert 0 (BecomeAtom *))&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Insert 1 (BecomeAtom 6))&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Insert 2 (BecomeAtom 9))&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This example makes a number of things clear: first that we can see the full ordering of events from the top level, and that work on sub-expressions may be arbitrarily interleaved. In the example above this is demonstrated by the insertion of the atom &lt;code&gt;12&lt;/code&gt; before the completion of the sub-expression &lt;code&gt;(* 6 9)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Second, that from each sub-level we see the ordering of events relevant to that sub-level. In this case, the precise ordering of the creation of the atoms &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;6&lt;/code&gt; and &lt;code&gt;9&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Third, it shines some light on some challenges. Namely, the example as given is horribly verbose, which makes it hard to read for humans and has implications on the performance characteristics of the implementation. For both these problems solutions have already been found, which will be presented in the next parts.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;This concludes the most basic introduction to the editor.&lt;/p&gt;

&lt;p&gt;We’ve seen the goal: having change available as a primitive, and being able to meaningfully express compositions over change. We’ve seen that it is a structured editor and why this should be so.&lt;/p&gt;

&lt;p&gt;We’ve also encountered the first design decisions: the decision for s-expressions as a basic syntax, and a particular choice for a &lt;em&gt;clef&lt;/em&gt; and how this is sufficient for the stated goals.&lt;/p&gt;

&lt;p&gt;In the next parts I’ll show the current prototype in action, and will discuss some of the open questions and implementation details.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:sicp&quot;&gt;
      &lt;p&gt;Asking the three questions “What are your primitives, what are your means of combination and what are your means of abstraction?” is directly inspired by Abelson &amp;amp; Sussman’s excellent lectures and book on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs&quot;&gt;Structure and Interpretation of Computer Programs&lt;/a&gt;. &lt;a href=&quot;#fnref:sicp&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:lists-not-tuples&quot;&gt;
      &lt;p&gt;The canonical definition of S-Expressions treats lists as mere syntactic sugar for nested pairs; i.e. &lt;code&gt;(x y z)&lt;/code&gt; is simply a shorthand for &lt;code&gt;(x . (y . (z . NIL)))&lt;/code&gt;. In this implementation the opposite approach is taken as to allow for primitives of change on such lists that are sufficiently expressive. &lt;a href=&quot;#fnref:lists-not-tuples&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:infinite-space&quot;&gt;
      &lt;p&gt;To see that there are literally infinitely many possible primitive operations of change, consider the following: there are infinitely many s-expressions, and we can always define a special operation of change for any given s-expression. &lt;a href=&quot;#fnref:infinite-space&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:imperative-functional-equivalence&quot;&gt;
      &lt;p&gt;The definitions are formulated in the imperative style (e.g. “delete at i”); an equivalent functional definition can be trivially constructed (“given a list, return an list without element i”). &lt;a href=&quot;#fnref:imperative-functional-equivalence&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;

  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/introducing-the-editor/&quot;&gt;Introducing the Editor&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on June 29, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Existing tools]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/existing-tools/" />
  <id>http://expressionsofchange.com/existing-tools</id>
  <published>2017-06-27T00:00:00+02:00</published>
  <updated>2017-06-27T00:00:00+02:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;p&gt;Arguably, the existence of so many tools is a strong indication that the underlying problem, that of dealing with change in software development, is one which requires tooling to be properly handled.&lt;/p&gt;

&lt;p&gt;The next questions is then: is it also an indication that this is a solved problem? Given that this site documents attempts to come up with better &lt;em&gt;Expressions of Change&lt;/em&gt;, it will not come as a surprise that my answer is an emphatic “NO”.&lt;/p&gt;

&lt;p&gt;My main gripe with currently existing solutions is that they suffer from a lack of generality. Even though all of them deal with managing change in software development, each of them is applicable only to a small part of the process. This means that one must use very different tools to solve almost identical problems. The problem is further exacerbated by the fact that the various tools are very poor at communicating with each other.&lt;/p&gt;

&lt;p&gt;The lack of generality might best be illustrated by examining a “day in the life” of the typical programmer and their interactions with the various tools.&lt;/p&gt;

&lt;h2 id=&quot;editing-programs&quot;&gt;Editing programs&lt;/h2&gt;

&lt;p&gt;Our day starts with some actual &lt;em&gt;programming&lt;/em&gt;. In other words: by editing one or more computer programs in a text editor or IDE. Though we may not explicitly realize it, this brings us into contact with the first tool to manage change: the capabilities of our editor to &lt;em&gt;undo &amp;amp; redo&lt;/em&gt;: In all but the most basic editors each change we make in our program is separately recorded in the working memory and we can always roll back the changes we made in anti-chronological order.&lt;/p&gt;

&lt;p&gt;Note that the capability to undo implies that a historic record is kept. This record is what’s used to be able to revert to any given state of the document.&lt;/p&gt;

&lt;p&gt;The ability to undo is so useful that it’s hard to imagine an editor without it — &lt;a href=&quot;/the-power-of-undo/&quot;&gt;something that I’ve written about in another article&lt;/a&gt;. This article is also where some of the typical limitations of undo are described, such as the fact that your undo-history is lost when you close the editor and the fact that the only way to roll back changes is in often anti-chronological order. Such limitations are not the focus here, instead we’ll zoom in on the discontinuity between undo and other tools. To do so, we’ll start with version control.&lt;/p&gt;

&lt;h2 id=&quot;version-control&quot;&gt;Version control&lt;/h2&gt;

&lt;p&gt;Let’s return to a day in the life of a typical programmer. After successfully making a number of changes in our program these changes are typically &lt;em&gt;committed&lt;/em&gt; to a &lt;em&gt;source repository&lt;/em&gt; using a &lt;em&gt;version control system&lt;/em&gt;, i.e. using some command like &lt;code&gt;git commit&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Version control systems are those systems that we use to track changes to the source code of computer programs. Git is currently the most popular choice (overwhelmingly so), Mercurial is a less popular modern system and Subversion and CVS are older but still-in-use systems. Because tracking changes the explicit goal of version control systems the relationship with the present article should be quite obvious.&lt;/p&gt;

&lt;p&gt;Version control systems are extremely useful: they allow us to go back to older versions of our program, compare versions, record notes about the intent of particular changes and work together with multiple people on the same project, among other things.&lt;/p&gt;

&lt;p&gt;In the above discussion of &lt;em&gt;undo&lt;/em&gt; we established that the capability to undo implies that a full historic record of all recent changes is kept in the editor. In the present discussion we’ve noted that the programmer’s primary tool for keeping long term historic records is a version control system. As such, both version control systems and our editor’s ability to undo deal with the same thing, namely change to the source code of our program, focusing on the short and long term records of changes respectively. This raises a number of questions:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Why do we need two tools for the single task of history-keeping? Is there really a fundamental difference between short term changes and long term changes?&lt;/li&gt;
  &lt;li&gt;Can the two tools communicate with each other? Do they speak a single language?&lt;/li&gt;
  &lt;li&gt;What would either tool look like if it gained the capabilities of the other?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I’ll try to answer these in the below.&lt;/p&gt;

&lt;h3 id=&quot;one-task-two-tools&quot;&gt;One task, two tools&lt;/h3&gt;

&lt;p&gt;First let’s examine why we have two tools for a single task. Why do we need a version control system at all, if we already had a historic log of changes in our editor?&lt;/p&gt;

&lt;p&gt;The first potential reason is that the capabilities of the historic record associated with &lt;em&gt;undo&lt;/em&gt; are often quite limited. The record is lost when the editor is closed, the record cannot be cleaned up, annotated or shared. Those limitations are, however, not the fundamental reason; in principle they can be taken away by adding more capabilities to our editor.&lt;/p&gt;

&lt;p&gt;One could also argue that the reason for the split lies in the different meaning attributed to the different tools by the programmer. In this line of reasoning, the undo capabilities of the editor represent private and temporary changes. Only once some stable, tested and cleaned up state is reached this is committed to version control. In other words: the split in tools is caused by a fundamental semantic difference between “private / short term” and “public / long term”.&lt;/p&gt;

&lt;p&gt;Even if such a semantic split would exist, it would not amount to a fundamental reason for a split in tools: the ability to clean up the editor’s undo history could simply be improved. If the tooling for such cleanup would be powerful enough, a cleaned up version of the editor’s history could still be publicly shared.&lt;/p&gt;

&lt;p&gt;Furthermore, the idea that you should commit to version control only once you’re “fully done” runs somewhat contrary to the prevailing wisdom. One of the core ideas that distributed version control systems bring to the table is precisely that there may be many different levels of “doneness”, and that the tooling should provide abilities to house those different levels within a single system. Two such abilities are the ability to work on your own separate branch of history or to commit often and only rewrite your history before sharing it with others.&lt;/p&gt;

&lt;p&gt;In short: there is no fundamental divide between “short term history” and “long term history”, but rather a continuum, and a split in two sets of tools is not a fundamental property of nature.&lt;/p&gt;

&lt;p&gt;Instead, the fundamental reason that we have two tools for a single task follows from the non-central position we have given editors in the dominant paradigm of program construction. This paradigm is roughly the following:&lt;/p&gt;

&lt;p&gt;A computer program is compiled from a collection of source &lt;em&gt;files&lt;/em&gt;. How these files themselves are constructed is &lt;em&gt;not important&lt;/em&gt;, to the compiler they “just are”. In other words: we’re agnostic about our &lt;em&gt;means of construction&lt;/em&gt;, focusing only on &lt;em&gt;constructed&lt;/em&gt; artifacts.&lt;/p&gt;

&lt;p&gt;There are certainly arguments in favor of this paradigm: because we’re agnostic about the editor, each developer can use their own set of tools, and even a single developer can switch between various editors and other tools in the construction of the program.&lt;/p&gt;

&lt;p&gt;It’s worth noting, however, how dominant this implicit paradigm is, even in situations where it’s not necessarily the most fitting one. Consider for example that even an IDE that fully integrates the whole workflow of the programmer, including version management is bound by the same paradigm, even when the programmer never leaves the IDE and the capability to use different editors or tools is never actually used in practice.&lt;/p&gt;

&lt;p&gt;The drawbacks of this paradigm become obvious when considering that version control systems are bound by it too. From the perspective of the version control system, editors do not exist, only files. Each time a commit is made, the current state of all relevant files is inspected, and the VCS makes educated guesses as to how this evolved from the previous state.&lt;/p&gt;

&lt;h3 id=&quot;talking-tools&quot;&gt;Talking tools&lt;/h3&gt;

&lt;p&gt;Now that we know what the prevailing paradigm is, we can also answer the second question: Is any meaningful communication between the editor’s short term historic records and the long term historic records of the VCS possible?&lt;/p&gt;

&lt;p&gt;Obviously not! From the perspective of the VCS, we are agnostic about what an editor even &lt;em&gt;is&lt;/em&gt;, let alone that we could communicate with it. This means that the fine grained historic record stored by the editor will never be made available to the VCS, and will be lost forever.&lt;/p&gt;

&lt;p&gt;Let’s take a look at two examples where such information could in fact be useful:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Intra-commit chronology&lt;/strong&gt; — often it’s semantically meaningful to present the changes within a single commit in a particular logical order. The goal would be: when examining the changes introduced by the commit, it’s easier to understand these if they’re presented in a meaningful order than any random order.&lt;/p&gt;

&lt;p&gt;For example: when a function’s call signature is updated, all calling locations must also be updated. It makes sense to present such a change in exactly that order: first show the change in the definition; then show all calling locations being updated.&lt;/p&gt;

&lt;p&gt;This happens to be the same order in which such a change would typically be made by the original programmer. This is not a coincidence: the actual order of construction is often a good starting point in coming up with a good order in explaining a change.&lt;/p&gt;

&lt;p&gt;It would be great if our tools would:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;allow us to present the changes of a single diff in a logical order and&lt;/li&gt;
  &lt;li&gt;allow us to use the actual order in which we made changes the diff as a basis for this logical order — possibly cleaning up the actual result before presenting it to others.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;However, version management systems don’t have ordering inside a single commit, and they cannot communicate with editors to find out what this basis chronology could be.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Post-hoc commit splitting&lt;/strong&gt; — when committing changes to the VCS, it’s best practice to make &lt;em&gt;atomic commits&lt;/em&gt;, i.e. to ensure that each commit deals with only one single conceptual change. However, when editing a computer program it’s not always possible to be concerned with only one thing at at a time. For example, the change you’re working on might necessitate some other changes, leading you to get “sucked into a rabbit hole” of refactorings.&lt;/p&gt;

&lt;p&gt;If you happen to have made a large number of changes without intermediate commits, you’re left to your own devices to construct such atomic commits after the fact. This is typically done using “patch mode”, i.e. by manually marking various hunks of code as either part of either a given commit.&lt;/p&gt;

&lt;p&gt;However, in actuality, the changes that are about to be committed have been made in a particular order. In many cases, this actual chronological order could be of great help in the construction of the atomic commits. (This assumes that changes that were made consecutively are more likely to be related than non-consecutive changes, which is indeed usually the case). This chronological information lives in the editor’s undo history, but is unfortunately not available while constructing the patch.&lt;/p&gt;

&lt;h3 id=&quot;capabilities&quot;&gt;Capabilities&lt;/h3&gt;

&lt;p&gt;Version control systems are in many ways more powerful than most editors’ capabilities to undo. The third question is: consider what kind of capabilities could be gained by transposing the full expressiveness of version control systems to the undo history of the editor. In this transposition the granularity that’s currently associated with the undo command, namely that of the single edit-action, should be preserved. Here are two examples:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The ability to work together on a single project on two or more computers, currently only realistically possible on the granularity of a version control “commit”, would become available while editing the program with the granularity of a single keystroke. In other words: proper support for Pair Programming.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The ability to visually inspect, navigate through and manipulate the history of the edit-process would become available at a lower level than the commit. Note that the current standard capabilities of typical editors, namely the combination of undo &amp;amp; redo, makes for a rather incomplete navigational commands. Consider for example the case where you undo a large number of changes and then make a new change: in that scenario the undone changes can no longer be restored using the “redo” command. Having full navigation through history available, this problem disappears.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;package-management&quot;&gt;Package management&lt;/h2&gt;

&lt;p&gt;Back to a day in the life of our programmer. Let’s say the program under consideration depends on a number of external libraries. Such libraries may depend on a number of other libraries themselves, which may depend on further libraries etc, forming a &lt;em&gt;dependency graph&lt;/em&gt;. Furthermore, each of these dependencies is to some specific version or range of versions; we cannot generally assume that each version of each library works well with each library it depends on, so we must specify which versions are known to work correctly. Such a situation is a natural consequence of two simple facts of life: The ever-changing nature of programs and the justified desire of programmers to decompose their programs into submodules.&lt;/p&gt;

&lt;p&gt;The tools to resolve the various dependencies mentioned above are known as “package management systems”. They typically come in either one of two flavors. Firstly various Operating Systems bundle a package manager to do system-wide installations of software, Examples are &lt;code&gt;apt&lt;/code&gt;, &lt;code&gt;yum&lt;/code&gt;, &lt;code&gt;pacman&lt;/code&gt; and &lt;code&gt;nix&lt;/code&gt;. Secondly there’s a great number of package management systems specific to a particular programming language — almost all programming languages seem to come with their own package manager (&lt;code&gt;pip&lt;/code&gt;, &lt;code&gt;gem&lt;/code&gt;, &lt;code&gt;cargo&lt;/code&gt;, to name just a few).&lt;/p&gt;

&lt;p&gt;One of of the main arguments of this article is that there are too many incompatible tools to deal with changing software. Regarding package management in particular, we can drive this point home in two ways. First, the sheer amount of different package management solutions is almost comical. One can also not help but wonder why so many tools of the same kind are necessary, and whether this is not an indication of a fundamental flaw in their design. Second, the fact that package managers are not only poorly able to talk with other tools for managing change, but can hardly speak among themselves, is a further indication of a deep problem.&lt;/p&gt;

&lt;p&gt;On the subject of inter-operation with other tools for managing change the following: Note that package management is yet another tool to deal with changing software, albeit with a slightly different focus than version control systems. The capabilities that each of the tools lack with respect to the other follow directly from this different focus:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Package management deals with the dependencies on and between a number of external “packages” which are taken more or less as a given. Package management systems have only very limited support for tracking history inside a single package. Some of the primary operations of version management systems, such as constructing histories, comparing versions and cooperating in teams are missing.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Version control systems, on the other hand, deals with a single repository of code under control of the user. This means that they lack the ability to naturally track versions across composed systems in a composed manner. Even though git offers some workarounds for this, such as &lt;code&gt;gitmodules&lt;/code&gt; and &lt;code&gt;git-subtree&lt;/code&gt;, such workarounds are fundamentally limited, for example because it’s not possible to arbitrarily nest them.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Version control systems’ assumption that there is a single repository of code forces the programmer to make a rather arbitrary decision: what is the single thing whose history they want to track? Possible choices are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Putting the entire company’s software development efforts in a single repository. Drawback: This conflates various tools and programs that may be entirely unrelated.&lt;/li&gt;
  &lt;li&gt;Identifying “projects” and giving each project (including its modules) its own repository. Drawback: The projects may in fact contain multiple modules that are reused across multiple projects; including their history as a part of one or more particular projects will make it harder to reuse improvements across projects.&lt;/li&gt;
  &lt;li&gt;Breaking up the projects into modules and managing each module’s history independently. Drawback: the relationship between changes to programs and their modules is hard to express.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each of the mentioned choices will have some drawbacks. This is only natural: the ability to recursively decompose programs into smaller sub parts is one of the core values of programming, so if we do away with it (as version control systems do) we will run into trouble immediately!&lt;/p&gt;

&lt;p&gt;Taking inspiration from package management tools, we could imagine a form of composable version management: the ability to manage the history of an arbitrary sub part of a program, while preserving the ability to have an integrated view of the history of any component that combines a number of parts.&lt;/p&gt;

&lt;p&gt;Taking such an approach to its radical extreme we can make the parts almost arbitrarily small or big: tracking the history of expressions, statements, methods, classes, modules, programs and systems, whereby each level of history is expressed as a composition of the histories at lower levels. The consequences of such an approach will be further explored in a later article.&lt;/p&gt;

&lt;p&gt;As far as I can see, version management with decent capabilities for composition would render package management tools entirely obsolete. For that reason the consequences of applying the ideas of VCSes to package management are not explored here.&lt;/p&gt;

&lt;h2 id=&quot;other-examples&quot;&gt;Other examples&lt;/h2&gt;

&lt;p&gt;There are a great number of other tools that deal with changing programs; They are mentioned here mostly to give an indication as to the quantity of such tools. I might explore the possible inter-relationships between them in a follow-up article.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Data/schema-migrations&lt;/strong&gt; — When the program is changed, its expectations about the data it interacts with may also change. For the case that the data is stored in a database, the tools to migrate data are usually called “data migrations” or “schema migrations”. Similar cases are that of a newer version of the program that expects a different configuration file format, and the case of a program that simply changes its document-format.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Provisioning &amp;amp; Containers&lt;/strong&gt; — tools such as &lt;code&gt;chef&lt;/code&gt;, &lt;code&gt;puppet&lt;/code&gt; and &lt;code&gt;ansible&lt;/code&gt; are often used when managing environments of similarly configured machines. They deal with many of the same challenges as package managers: getting the right versions of the right dependencies in the right place. Similar remarks can be made about &lt;em&gt;containers&lt;/em&gt; (Docker being a currently popular solution): one might say that their greatest value is in being able to precisely reproduce an entire environment of dependencies to a specific set of versions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Build tools&lt;/strong&gt; — build tools such as &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;maven&lt;/code&gt; and &lt;code&gt;ant&lt;/code&gt; take responsibility for the compilation of larger programs. They relate to change in software in the sense that [a] they’re responsible for detecting which parts of the system have changed, and must therefore be rebuilt and [b] they may specifically talk about particular versions of dependencies of the build.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;There is a large amount of tools to manage the ever-changing nature of software.&lt;/p&gt;

&lt;p&gt;One could argue that this is an indication that we’re dealing with a solved problem and that further thinking about &lt;em&gt;Expressions of Change&lt;/em&gt; is not required.&lt;/p&gt;

&lt;p&gt;Personally, I’m taking as an indication of the opposite; I’m especially emboldened by the fact that the various tools cannot even properly talk to each other, despite them being (largely) dealing with problems in the same sphere.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/existing-tools/&quot;&gt;Existing tools&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on June 27, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[The power of Undo]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/the-power-of-undo/" />
  <id>http://expressionsofchange.com/the-power-of-undo</id>
  <published>2017-06-14T00:00:00+02:00</published>
  <updated>2017-06-14T00:00:00+02:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;p&gt;Let’s why this could be so, by considering the following workflow:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A person is interacting with a computer system with certain goals in mind&lt;/li&gt;
  &lt;li&gt;They try to express these goals in the language of the system, by issuing certain commands.&lt;/li&gt;
  &lt;li&gt;If the command brings you closer to the goal issue another one.&lt;/li&gt;
  &lt;li&gt;If the command brings you further from the goal:
    &lt;ol&gt;
      &lt;li&gt;If undo is available as a command, undo.&lt;/li&gt;
      &lt;li&gt;If undo does not exist, it’s not clear how to back on track - and even whether getting back on track is possible at all!&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In other words: the ability to undo amounts to an enormous increase of &lt;em&gt;control&lt;/em&gt; of the human actor over the system they are commanding, by allowing them to to roll back mistakes, even potentially very destructive ones.&lt;/p&gt;

&lt;p&gt;This increase of control has a 1-to-1 mapping with a decrease in &lt;em&gt;fear&lt;/em&gt;: the more sure you are that you can always undo mistakes, the less afraid you will be to make them. Such fear is most obviously visible when observing at those with low computer literacy in their interactions with computers, but it applies to everyone. This very emotion then hinders further learning, because it stands in the way of experimenting and gaining feedback about the way the system works.&lt;/p&gt;

&lt;p&gt;Note that the increase of control and decrease of fear that undo brings is available even when your further knowledge of the system is very limited - as long as you’re confident that you can undo any action, you’re free to explore. In other words: Undo brings control in face of the unknown - quite a capability indeed!&lt;/p&gt;

&lt;p&gt;By the way: the capability to undo is a typical example of an &lt;em&gt;Expression of Change&lt;/em&gt; - the actions to be undone being the change about which we express ourselves.&lt;/p&gt;

&lt;h2 id=&quot;common-limitations&quot;&gt;Common limitations&lt;/h2&gt;

&lt;p&gt;Given how powerful the ability to undo is it’s worthwhile examining if it can be made even more powerful. To do so, let’s look at some limitations that typically apply in common desktop applications. The definition of “typically” is obviously up for debate, and thankfully there are many applications which do not suffer from one or more of the below limitations. In any case, “single undo only” and “no redo” are not mentioned below because most reasonably modern applications have virtually infinite undo as well as the ability to redo.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Discard on close&lt;/strong&gt; - the ability to undo is lost when closing and reopening your editor. You may be able to save documents, but saving documents including their full undo history is not possible.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Lack of discoverability&lt;/strong&gt; - the ability to undo is offered as a menu option and keyboard shortcut, but the historic record of changes cannot itself be inspected visually, saved or manipulated.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Linear undo only&lt;/strong&gt; - the ability to undo is only available in anti-chronological order, i.e. by undoing the last change first, the second last second etc. It’s not possible to undo (or even more powerfully: edit) arbitrary changes in the past without undoing all follow-ups first.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;No redo after do&lt;/strong&gt; - when undoing a number of changes, and then making an arbitrary new change, the undone changes can no longer be redone. In other words: the state your document was in before undoing is not always reachable after the undo. Equivalently: the action of undo itself cannot always be undone.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Monolithic context&lt;/strong&gt; - each document has a single undo history; when the document is composed of multiple parts or sections these do not have their own histories. Similarly, when multiple documents form a conceptual unit, such as the source tree of a computer program, undo is not available across documents but only at the level of a single document.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Undo is great, let’s have more of it.&lt;/p&gt;

&lt;p&gt;We seen what limitations commonly apply in currently existing applications.&lt;/p&gt;

&lt;p&gt;The challenge of this site is then simply: to come up with undo-like capabilities that don’t suffer from these limitations, like so:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Undo after close&lt;/strong&gt; - the ability to undo is preserved even after the application has crashed or has been closed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Change as a first level citizen&lt;/strong&gt; - the historic record can be inspected, saved and manipulated like any other object in our system.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Arbitrary graph traversal&lt;/strong&gt; - we have the ability to revert to any state of the document as it once existed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Decompositon of context&lt;/strong&gt; - for structured documents undo is available on arbitrary parts of the document, parts consisting of other parts, and the document as a whole.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This site documents work in progress; stay tuned for updates.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/the-power-of-undo/&quot;&gt;The power of Undo&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on June 14, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Self applicability]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/self-applicability/" />
  <id>http://expressionsofchange.com/self-applicability</id>
  <published>2017-06-10T00:00:00+02:00</published>
  <updated>2017-06-10T00:00:00+02:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;p&gt;We’ll take a look at the practice of &lt;em&gt;rewriting history&lt;/em&gt;, why we would want to do that and how it creates two seemingly irreconcilable goals: staying true to what actually happened on the one hand and the ability to tell the most clear story about history on the other. Then we’ll see how we can reconcile these goals by applying the idea of version control to version control itself.&lt;/p&gt;

&lt;h2 id=&quot;editing-programs&quot;&gt;Editing Programs&lt;/h2&gt;

&lt;p&gt;To be able to properly discuss all this, we’ll start at the very beginning: by examining some very minimal examples of the construction of a computer program.&lt;/p&gt;

&lt;p&gt;To describe these, we’ll use pen, paper, an eraser and a pair of scissors - this way everything stays simple and visual. Note that this description is no less general than the usual process of constructing programs on an actual computer: wherever we talk about “pieces of paper”, we can simply substitute “one or more files”.&lt;/p&gt;

&lt;p&gt;Say that on a given Monday we’re given the task to write a simple program. We do so by writing this on our piece of paper and call it a day.&lt;/p&gt;

&lt;p&gt;At some point soon after, let’s say on Tuesday, the need arises for a more advanced program. We erase part of our program and add some new parts to reflect this, like so:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/movies/editing-programs.gif&quot; alt=&quot;Editing a program.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now, if we discover a bug in our program on Wednesday, we’re faced with a problem: we cannot simply go back to Monday’s version of the program, because it no longer exists. Nor can we compare Monday and Tuesday’s versions to reason about them.&lt;/p&gt;

&lt;p&gt;This is caused by the fact that changing the program brings with it the loss of information. This is particularly obvious in our example because we’re literally erasing part of the first program to write the second. Note however that even if we only ever add to the program, we destroy the knowledge of what the program looked like before the additions.&lt;/p&gt;

&lt;h2 id=&quot;version-control&quot;&gt;Version Control&lt;/h2&gt;

&lt;p&gt;To be able to keep the old versions around we could use a modern Version Control System such as Git. In addition to the ability to go back or forward to an arbitrary version of the program, this will allow us to compare versions, work together with other people and merge diverging lines of development.&lt;/p&gt;

&lt;p&gt;In our pen &amp;amp; paper world we will model Version Control by using an extra piece of paper. On this we draw the versions of the program as nodes, annotate these with some meta-data (date, author, description), and connect them by arrows into a directed acyclic graph that describes the history of the program.&lt;/p&gt;

&lt;p&gt;The graph may be constructed by copying a given current state of the program over to this second piece of paper and adding the relevant metadata. This corresponds to a &lt;code&gt;git commit&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can then navigate through this graph by pointing at a given node with our finger (below: a big red arrow), and copying the node’s content over into the current program state. This corresponds to a &lt;code&gt;git checkout&lt;/code&gt;. Because we always have the full history available, we’ve solved our initial problem!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/movies/version-control.gif&quot; alt=&quot;Version Control&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;rewriting-history&quot;&gt;Rewriting History&lt;/h2&gt;

&lt;p&gt;An important value for a historic record is its historic accuracy: the fact that it precisely reflects what actually happened. In Version Control as discussed so far, historic accuracy is guaranteed by the means of construction of the historic record. There are various versions of the program, and they each get added to the graph as they are created.&lt;/p&gt;

&lt;p&gt;In the toy example above we established the need for Version Control by talking about a simple means of going back in time. In larger projects, the historic information becomes more than a simple time machine: it becomes a repository of knowledge about the history of the project, offering insight in questions of intent. This value is further enhanced by best practices such as writing meaningful descriptions for each version and ensuring a single version contains only a single set of related changes. In the light of this role, another value for a historic record emerges: the clarity of the record - records that are more clearly understandable by users being better than ones that are hard to understand.&lt;/p&gt;

&lt;p&gt;Sometimes the values of accuracy and clarity are at odds with each other: most clear story about history is not told by the description of history as it actually happened, but rather by some simplification or cleanup. In such cases a may be useful to &lt;em&gt;rewrite history&lt;/em&gt;. Here are some examples of such rewrites with their equivalent &lt;code&gt;git&lt;/code&gt; commands:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;If you make a mistake while adding a version to the historic record, you may want to fix the mistake in the record rather than adding yet another version to fix the mistake (such a version would only clutter the record). (&lt;code&gt;git commit --ammend&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;History is not always linear; multiple new version may arise based on a single version of the program. Such diverging histories can later be merged together in a separate “merge” version. However, many such separate version will clutter up the historic record, and are therefore sometimes deemed undesirable. The solution is to rewrite history as if the divergence never took place: one of the diverging branches of history is cut from its actual base, rewritten, and pasted at the tail of the other branch in a single linear fashion. (&lt;code&gt;git --rebase -i&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;An animation of a &lt;code&gt;git rebase&lt;/code&gt; in our pen &amp;amp; paper world is shown below: the commit “C” is rewritten as if it happened after “B”, rather than independently of it; this simplifies the graph because we no longer need a merging commit.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/movies/rewriting-history.gif&quot; alt=&quot;Rewriting History&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As should be obvious from these two examples, rewriting of history can be quite helpful in increasing the clarity of the historic record by removing clutter in the form of irrelevant details. It does, however, come at a price; one which is hinted at by the use of scissors in the animation.&lt;/p&gt;

&lt;p&gt;Firstly, it violates precisely the goals as stated in the initial example: a true historic record without loss of information. This is not merely a theoretical problem: consider the case of a rebased version which has some kind of bug. For such a bug it is impossible to say whether it was introduced as a direct consequence of the rebasing or was also present in the unrebased version. Given that such understanding is precisely what version control is about, this is really unfortunate.&lt;/p&gt;

&lt;p&gt;Secondly, consider the fact that version control forms an important safety net in our software development process: when we make mistakes we can undo them by going back to an older version. However, while rewriting history we don’t have the capability of reverting mistakes made in the rewriting process itself. This is precisely why most blog articles about rewriting of history in Git are annotated with big red warning boxes.&lt;/p&gt;

&lt;p&gt;So far we’ve seen two seemingly irreconcilable goals: “true history” and a “clear history”. Because the goals are presented as an either/or choice, striking some balance is left as a matter of culture or taste to individual users and teams. It has been my personal observation that users of Mercurial often err on the side of accuracy, whereas users of Git prefer clean histories, but your mileage may vary.&lt;/p&gt;

&lt;h2 id=&quot;self-applicable-version-control&quot;&gt;Self Applicable Version Control&lt;/h2&gt;

&lt;p&gt;The question that seems to remain unasked is: is it be possible to have a historic record that’s both truthful to what actually happened and a clear description that leaves out irrelevant details?&lt;/p&gt;

&lt;p&gt;To answer this, let’s go back to the running example of keeping track of our program and the history of our program on a piece of paper. So far we’ve seen the following:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The Program
    &lt;ol&gt;
      &lt;li&gt;A piece of paper may be used to write a program.&lt;/li&gt;
      &lt;li&gt;At some point new features are requested, and we must edit the program.&lt;/li&gt;
      &lt;li&gt;Once we do this lose information about previous versions of the program.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Version Control
    &lt;ol&gt;
      &lt;li&gt;A piece of paper may be used to keep track of a historic graph of all programs from step 1.&lt;/li&gt;
      &lt;li&gt;It may be useful to clean up this graph by rewriting history for reasons of clarity.&lt;/li&gt;
      &lt;li&gt;Once we edit the historic graph we lose information about previous versions of the history.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We’ve seen that the problem mentioned in step 1c was solved by step 2a; and that we have an as of yet unsolved problem in step 2c. The question then is: can we think of a step 3a to solve this?&lt;/p&gt;

&lt;p&gt;Sure: we can simply add yet another piece of paper containing a historic graph, just like we did in step 2a. The only difference being the content of the nodes of the graph: rather than keeping track of individual programs, we can track the history of historic graphs. Let’s call this graph a 2nd level history.&lt;/p&gt;

&lt;p&gt;Construction of this graph is analogous to the construction of the regular historic graph: whenever we change the historic record, we add a full copy of the historic graph to the second-level history as a node. We do this both for any history writing operations (such as a &lt;code&gt;git commit&lt;/code&gt;) as for rewriting operations (such as &lt;code&gt;git rebase&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Just like in the case of regular Version Management we can navigate through the newly constructed graph. Navigation through a second level history corresponds to changes in the historic graph (rather than changes to the program). In other words: it corresponds to rewrites of history. Here it is in action:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/movies/vcs-squared.gif&quot; alt=&quot;History of History&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Note that we’ve achieved our goal now! We can rewrite our first level history to be as clear as possible, while keeping a record of precisely what actually happened available in our second level history. This gives us the ability to un-rewrite history just as easily as reverting back to a previous version of our program.&lt;/p&gt;

&lt;p&gt;We did this simply by applying the idea of Version Control on itself: we use Version Control on graphs representing Version Control. This is hardly a unique idea in the field: other examples are using compilers to compile compilers and applying functions to functions to yield further functions.&lt;/p&gt;

&lt;h2 id=&quot;down-the-rabbit-hole&quot;&gt;Down the rabbit hole&lt;/h2&gt;

&lt;p&gt;Now that we’ve seen that the concept of tracking change is self-applicable, we may ask how often we may want to self-apply. Is it possible to talk about third or nth level histories, i.e. histories of histories of histories or even deeper levels? Secondly: is there any use for such expressions?&lt;/p&gt;

&lt;p&gt;The first question is easily answered: yes, we can always keep adding more layers. Any Version Control which doesn’t care what’s under control can always be used to wrap an &lt;em&gt;n - 1&lt;/em&gt; level history to yield an &lt;em&gt;n&lt;/em&gt; level history.&lt;/p&gt;

&lt;p&gt;Now for the second question: are such deep self-applications of any use? To this, I do not yet know the answer.&lt;/p&gt;

&lt;p&gt;In general, to get the advantages of Version Control in all parts of your system, you need precisely one more level of history than the amount of levels on which you want to make potentially destructive changes.&lt;/p&gt;

&lt;p&gt;So far, we’ve seen that making of destructive changes on the first level of history (“rewriting history”) is occasionally quite useful, and that we may therefore want to introduce a second level of history.&lt;/p&gt;

&lt;p&gt;Because we lack actual experience with such a second level history, use cases for destructively editing that have not yet shown themselves. It may be that they don’t actually exist; in which case we’re done. If they do, a third level might be useful. In any case, it would seem that for each level the amount of usage decreases, an that we at some point run out of the need for further levels.&lt;/p&gt;

&lt;h2 id=&quot;self-applicable-git&quot;&gt;Self-applicable Git&lt;/h2&gt;

&lt;p&gt;Implementing the above insights using a typical modern Version Control System such as Git does, unfortunately, not lead to very useful results.&lt;/p&gt;

&lt;p&gt;This is caused by the following: In the above we made no assumptions about the nature of the pieces of paper - other than that they could be stored as a file on a computer.&lt;/p&gt;

&lt;p&gt;Git and comparable systems, on the contrary, do make specific assumptions: most modern Version Control systems are built on the assumption that the files they are tracking are almost exclusively text files.  Even though storing the occasional small binary file is certainly technically possible, storing large numbers of large binary files in Git is certainly not recommended, and will not lead to a workable system.&lt;/p&gt;

&lt;p&gt;The Git repository itself is implemented precisely as a collection of binary files. This means that tracking the history of a Git repository cannot be done efficiently using Git.&lt;/p&gt;

&lt;p&gt;In fact: trying this one runs into the fact that adding Git repositories to be tracked inside other repositories has been explicitly forbidden: git repositories are managed using a directory called &lt;code&gt;.git&lt;/code&gt;, and Git raises an error when presented with a directory named &lt;code&gt;.git&lt;/code&gt; to track.&lt;/p&gt;

&lt;h2 id=&quot;implementation-hint&quot;&gt;Implementation hint&lt;/h2&gt;

&lt;p&gt;In the pen-and-paper examples of this article, the trackable items of interest (whether computer programs or complete n-histories) were always presented as files. Tracking such files was presented as adding the full state at any given point in time as a historic node to the graph.&lt;/p&gt;

&lt;p&gt;This approach does not generally scale to n-level histories: the storage requirements at each level grow like so:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;the 1-history stores all programs, i.e. growth linearly with program size and version count.&lt;/li&gt;
  &lt;li&gt;the 2-history stores all 1-histories, i.e. growth linearly with [1] and version count.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In this approach, the storage requirements for a given n-history’s are &lt;em&gt;O(p * v&lt;sup&gt;n&lt;/sup&gt;)&lt;/em&gt;. (&lt;em&gt;p&lt;/em&gt; for program size, &lt;em&gt;v&lt;/em&gt; for number of stored versions and &lt;em&gt;n&lt;/em&gt; for n-level-history)&lt;/p&gt;

&lt;p&gt;An important observation is that the actual (human) user actions that give rise to this growth is much more limited. The actual things the user can do are limited to:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Make direct changes to the program.&lt;/li&gt;
  &lt;li&gt;Calling various commands of (a n-level) Version Control system&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If we only store such user-actions into the various levels of Version Control, we’ll get a system that scales linearly with user input.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next steps&lt;/h2&gt;

&lt;p&gt;In this article I’ve shown (hopefully) how applying the ideas of Version Control on their own data-structures can be quite useful.&lt;/p&gt;

&lt;p&gt;We’ve also seen that having the property of self-applicability is not a given - e.g. Git cannot meaningfully be applied on Git repositories.&lt;/p&gt;

&lt;p&gt;I expect to be adding some example programs to this site at some point in the future. Inasmuch as those programs will be like Version Control systems, the ability to self-apply is an important design goal.&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/self-applicability/&quot;&gt;Self applicability&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on June 10, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Build once, maintain forever]]></title>
  <link rel="alternate" type="text/html" href="http://expressionsofchange.com/build-once-maintain-forever/" />
  <id>http://expressionsofchange.com/build-once-maintain-forever</id>
  <published>2017-06-07T00:00:00+02:00</published>
  <updated>2017-06-07T00:00:00+02:00</updated>
  <author>
    <name>Klaas van Schelven</name>
    <uri>http://expressionsofchange.com</uri>
    <email>klaas@vanschelven.com</email>
  </author>
  <content type="html">&lt;p&gt;Now, you would like to just be able to build this site once, and once you’re satisfied with it, put it somewhere and be done with the technical side of things forever. Any maintenance to the site should then be restricted to updating the actual contents of the site.&lt;/p&gt;

&lt;p&gt;This is, as it stands, impossible: to be somewhat confident the site doesn’t get hacked, you need to run regular upgrades of the software the site was built on (Operating System, Database technology, Web Frameworks etc. etc.) Any of these upgrades may bring down the site, so they must to some degree be manual. At the very least you must always check whether the upgrade was successful, and if it wasn’t, you’ll need to manually figure out why it wasn’t and somehow fix it (again: manually).&lt;/p&gt;

&lt;p&gt;The reason for this is that the upgraded software libraries will work in slightly different ways from their predecessors, breaking the expectations of your software. This can be mitigated, but only to a degree.&lt;/p&gt;

&lt;p&gt;Firstly, the maintainers of the libraries may provide specific “security support” for specific older versions of their libraries. By restricting the upgrades of libraries to such security upgrades, which are smaller in both number and scope, you will certainly reduce the amount of required manual intervention. Unfortunately, even “security upgrades” are not guaranteed to be free from breakage, so manual intervention cannot be ruled out completely. Furthermore:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Security support for older versions is not eternal&lt;/li&gt;
  &lt;li&gt;The challenge of doing only minimal upgrades is made harder by the fact that the various libraries we build on may have dependencies amongst themselves&lt;/li&gt;
  &lt;li&gt;Our “package manager” may introduce further constraints on the available versions of libraries&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In any case, once the security support stops, you’ll have to do the regular upgrades after all, and you’ll still be confronted with the full scope of the original problem.&lt;/p&gt;

&lt;p&gt;A second way to mitigate the problem of running upgrades is to offload part of the work to other parties. You may, for example, rent a platform of up to date software; leaving the upgrading of the platform to an external party.&lt;sup id=&quot;fnref:saas-iaas&quot;&gt;&lt;a href=&quot;#fn:saas-iaas&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; In some cases, such an approach will actually create further problems of its own, for example when your infrastructure provider decides to apply upgrades which are incompatible with your software, and does so while you’re sleeping. The more fundamental issue is that paying someone else to do part of the work is merely hiding the real problem, which is that the work exists in the first place.&lt;/p&gt;

&lt;p&gt;In short: the state of the art of running a small website is “build once, manually maintain forever”. This burden of maintenance is largely caused by changes in &lt;em&gt;other software&lt;/em&gt;, as opposed to changes in our own requirements.&lt;/p&gt;

&lt;p&gt;The project on this website is to come up with (experimental) solutions for this problem and others. This is an ongoing project.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:saas-iaas&quot;&gt;
      &lt;p&gt;Arguably that the popularity of Software as a Service and Infrastructure as a Service is further evidence for the case: the unmanageability of software upgrades is so big that it has created a market of its own! &lt;a href=&quot;#fnref:saas-iaas&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;

  &lt;p&gt;&lt;a href=&quot;http://expressionsofchange.com/build-once-maintain-forever/&quot;&gt;Build once, maintain forever&lt;/a&gt; was originally published by Klaas van Schelven at &lt;a href=&quot;http://expressionsofchange.com&quot;&gt;Expressions of Change&lt;/a&gt; on June 07, 2017.&lt;/p&gt;</content>
</entry>

</feed>
